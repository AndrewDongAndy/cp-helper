{
    "Run Tests": {
        "scope": "cpp",
        "prefix": "runtests",
        "body": ["/*"," * author:  ADMathNoob"," * created: 12/20/21 16:12:21"," * problem: https://dmoj.ca/problem/coci18c2p5"," */","","/*","","*/","","#include <bits/stdc++.h>","","using namespace std;","","int main() {","  ios::sync_with_stdio(0);","  cin.tie(0);","  popen(\"g++ \", \"r\");","  return 0;","}"],
        "description": "Run Tests",
    }
    ,
    "With Demands": {
        "scope": "cpp",
        "prefix": "withdemands",
        "body": ["template <typename T>","class FlowWithDemands {"," public:","  int n;","  int source;","  int sink;","  FlowGraph<T> fg;","  T total_demand;","","  FlowWithDemands(int _n, int _source, int _sink) : n(_n), source(_source), sink(_sink), fg(_n + 2, _n, _n + 1) {","    fg.add(sink, source, numeric_limits<T>::max(), 0);","    total_demand = 0;","  }","","  void add(int from, int to, int demand, int cap) {","    fg.add(n, to, demand, 0);","    fg.add(from, n + 1, demand, 0);","    fg.add(from, to, cap - demand, 0);","    total_demand += demand;","  }","","  bool solve() {","    return (fg.max_flow() == total_demand);","  }","};"],
        "description": "With Demands",
    }
    ,
    "Dinic": {
        "scope": "cpp",
        "prefix": "dinic",
        "body": ["template <typename T>","class FlowGraph {"," public:","  static constexpr T EPS = (T) 1e-9;","","  struct Edge {","    int from;","    int to;","    T c;","    T f;","  };","","  int n;","  vector<vector<int>> g;","  vector<Edge> edges;","  int source, sink;","  T flow;","","  vector<int> ptr; // for ensuring the DFS for sending flow is O(n + m) time","  vector<int> dist;","  vector<int> que;","","  explicit FlowGraph(int _n, int _source, int _sink)","      : n(_n), g(n), source(_source), sink(_sink), ptr(n), dist(n) {","    assert(0 <= source && source < n);","    assert(0 <= sink && sink < n);","    assert(source != sink);","    flow = 0;","  }","","  void clear_flow() {","    for (Edge& e : edges) {","      e.f = 0;","    }","    flow = 0;","  }","","  void add(int from, int to, T forward_cap, T backward_cap) {","    assert(0 <= from && from < n && 0 <= to && to < n);","    g[from].push_back((int) edges.size());","    edges.push_back({from, to, forward_cap, 0});","    g[to].push_back((int) edges.size());","    edges.push_back({to, from, backward_cap, 0});","  }","","  bool expath() {","    fill(dist.begin(), dist.end(), -1);","    que.assign(1, source);","    dist[source] = 0;","    for (int b = 0; b < (int) que.size(); b++) {","      int v = que[b];","      for (int id : g[v]) {","        const Edge& e = edges[id];","        if (e.c - e.f > EPS && dist[e.to] == -1) {","          dist[e.to] = dist[v] + 1;","          if (e.to == sink) {","            return true;","          }","          que.push_back(e.to);","        }","      }","    }","    return false;","  }","","  T dfs(int v, T w) {","    if (v == sink) {","      return w;","    }","    while (ptr[v] < (int) g[v].size()) {","      int id = g[v][ptr[v]];","      Edge& e = edges[id];","      Edge& back = edges[id ^ 1];","      if (e.c - e.f > EPS && dist[e.to] == dist[v] + 1) {","        T t = dfs(e.to, min(e.c - e.f, w));","        if (t > EPS) {","          e.f += t;","          back.f -= t;","          return t;","        }","      }","      // don't increment the pointer if flow could be sent;","      // only rule out this edge if no more flow can be sent along it","      ++ptr[v];","    }","    return 0;","  }","","  T max_flow() {","    while (expath()) {","      fill(ptr.begin(), ptr.end(), 0);","      T big_add = 0;","      while (true) {","        T add = dfs(source, numeric_limits<T>::max());","        if (add <= EPS) {","          break;","        }","        big_add += add;","      }","      // blocking flow found","      if (big_add <= EPS) {","        break;","      }","      flow += big_add;","    }","    return flow;","    // final blocking flow found","  }","","  vector<bool> min_cut() {","    max_flow();","    vector<bool> ret(n);","    for (int i = 0; i < n; i++) {","      ret[i] = (dist[i] == -1);","    }","    return ret;","    // returns the partition of each node:","    // 0 - source side; 1 - sink side","  }","};"],
        "description": "Dinic",
    }
    ,
    "Hungarian": {
        "scope": "cpp",
        "prefix": "hungarian",
        "body": ["template <typename T>","class Hungarian {","  static constexpr T INF = numeric_limits<T>::max();",""," public:","  int n;","  int m;","  vector<vector<T>> a;","  vector<T> u;","  vector<T> v;","  vector<int> pa;","  vector<int> pb;","  vector<int> way;","  vector<T> minv;","  vector<bool> used;","","  Hungarian(int _n, int _m) : n(_n), m(_m) {","    assert(n <= m);","    a = vector<vector<T>>(n, vector<T>(m));","    u = vector<T>(n + 1);","    v = vector<T>(m + 1);","    pa = vector<int>(n + 1, -1);","    pb = vector<int>(m + 1, -1);","    way = vector<int>(m, -1);","    minv = vector<T>(m);","    used = vector<bool>(m + 1);","  }","","  inline void add_row(int i) {","    fill(minv.begin(), minv.end(), INF);","    fill(used.begin(), used.end(), false);","    pb[m] = i;","    pa[i] = m;","    int j0 = m;","    do {","      used[j0] = true;","      int i0 = pb[j0];","      T delta = INF;","      int j1 = -1;","      for (int j = 0; j < m; j++) {","        if (!used[j]) {","          T cur = a[i0][j] - u[i0] - v[j];","          if (cur < minv[j]) {","            minv[j] = cur;","            way[j] = j0;","          }","          if (minv[j] < delta) {","            delta = minv[j];","            j1 = j;","          }","        }","      }","      for (int j = 0; j <= m; j++) {","        if (used[j]) {","          u[pb[j]] += delta;","          v[j] -= delta;","        } else {","          minv[j] -= delta;","        }","      }","      j0 = j1;","    } while (pb[j0] != -1);","    do {","      int j1 = way[j0];","      pb[j0] = pb[j1];","      pa[pb[j0]] = j0;","      j0 = j1;","    } while (j0 != m);","  }","","  inline T current_score() {","    return -v[m];","  }","","  inline T solve() {","    for (int i = 0; i < n; i++) {","      add_row(i);","    }","    return current_score();","  }","};"],
        "description": "Hungarian",
    }
    ,
    "Mcmf": {
        "scope": "cpp",
        "prefix": "mcmf",
        "body": ["template <typename T, typename C>","class MCMF {"," public:","  static constexpr T EPS_T = (T) 1e-9;","  static constexpr C INF_C = numeric_limits<C>::max() / 2;","  ","  struct Edge {","    int from;","    int to;","    T c;","    T f;","    C cost;","  };","","  int n;","  vector<vector<int>> g;","  vector<Edge> edges;","","  explicit MCMF(int _n) : n(_n), g(n) {","  }","","  void add(int from, int to, T forward_cap, T backward_cap, C cost) {","    assert(0 <= from && from < n && 0 <= to && to < n);","    g[from].push_back((int) edges.size());","    edges.push_back({from, to, forward_cap, 0, cost});","    g[to].push_back((int) edges.size());","    edges.push_back({to, from, backward_cap, 0, -cost});","  }","","  pair<T, C> max_flow_min_cost(int st, int fin) {","    T flow = 0;","    C cost = 0;","    while (true) {","      vector<C> dist(n, INF_C);","      vector<bool> in_queue(n, false);","      vector<int> que(1, st);","      vector<int> pe(n);","      dist[st] = 0;","      in_queue[st] = true;","      bool found = false;","      for (int b = 0; b < (int) que.size(); b++) {","        int v = que[b];","        if (v == fin) {","          found = true;","        }","        in_queue[v] = false;","        for (int id : g[v]) {","          const Edge& e = edges[id];","          int to = e.to;","          if (e.c - e.f > EPS_T && dist[v] + e.cost < dist[to]) {","            dist[to] = dist[v] + e.cost;","            pe[to] = id;","            if (!in_queue[to]) {","              que.push_back(to);","              in_queue[to] = true;","            }","          }","        }","      }","      if (!found) {","        break;","      }","      T push = numeric_limits<T>::max();","      int v = fin;","      while (v != st) {","        const Edge& e = edges[pe[v]];","        push = min(push, e.c - e.f);","        v = e.from;","      }","      v = fin;","      while (v != st) {","        Edge& e = edges[pe[v]];","        e.f += push;","        Edge& back = edges[pe[v] ^ 1];","        back.f -= push;","        v = e.from;","      }","      flow += push;","      cost += push * dist[fin];","    }","    return {flow, cost};","  }","};"],
        "description": "Mcmf",
    }
    ,
    "Sparse Table": {
        "scope": "cpp",
        "prefix": "sparsetable",
        "body": ["template <typename T, class F = function<T(const T&, const T&)>>","class SparseTable {"," public:","  int n;","  vector<vector<T>> mat;","  const F f;","","  SparseTable(const vector<T>& a, const F& _f) : f(_f) {","    n = (int) a.size();","    assert(n > 0);","    int max_log = __lg(n) + 1;","    mat.resize(max_log);","    mat[0] = a;","    for (int lg = 1; lg < max_log; lg++) {","      mat[lg].resize(n - (1 << lg) + 1);","      for (int i = 0; i <= n - (1 << lg); i++) {","        mat[lg][i] = f(mat[lg - 1][i], mat[lg - 1][i + (1 << (lg - 1))]);","      }","    }","  }","","  T get(int ll, int rr) {","    assert(0 <= ll && ll <= rr && rr < n);","    int lg = __lg(rr - ll + 1);","    return f(mat[lg][ll], mat[lg][rr - (1 << lg) + 1]);","  }","};"],
        "description": "Sparse Table",
    }
    ,
    "Psegtree": {
        "scope": "cpp",
        "prefix": "psegtree",
        "body": ["namespace persistent_segtree {","","// not all of these functions have been tested!!!","","/**"," * A node of the persistent segment tree."," */","struct Node {","  Node* l = NULL;","  Node* r = NULL;","  // declare extra variables:","  $1","","  /**","   * Applies the given update to the Node.","   * ","   * @param from the left endpoint of the range covered by this Node","   * @param to the right endpoint of the range covered by this Node","   */","  void apply(int from, int to, $2) {","    // apply update to this node:","    $3","  }","};","","/**"," * Returns a copy of the given Node*."," * "," * @param v the Node* to make a copy of"," * @return the copy of the given Node*"," */","Node* copy(Node* v) {","  Node* u = new Node;","  *u = *v;","  return u;","}","","/**"," * Merges the data of nodes a and b into res."," * "," * @param res the Node& to store the merged result"," * @param a the left child; cannot be NULL"," * @param b the right child; cannot be NULL"," */","void unite(Node& res, const Node& a, const Node& b) {","  // pull the data from a and b to res; don't modify res.l and res.r","  $5","}","","void pull(Node* x) {","  assert(x->l != NULL && x->r != NULL);","  unite(*x, *x->l, *x->r);","}","","/**"," * Pushes the pending updates at x to its children."," * "," * @param x the node whose updates to push down"," * @param l the left endpoint of x's range"," * @param r the right endpoint of x's range"," */","void push(Node* x, int l, int r) {","  // push updates from x to x->l and x->r","  // only when range updates are used","  // assert(l != r && x->l != NULL && x->r != NULL);","  $6","","  // propagation has to happen on to new nodes","  // Node* u = copy(x->l);","  // Node* v = copy(x->r);","  // x->l = u;","  // x->r = v;","  // int y = (l + r) >> 1;","  // if (x->x == 1) {","  //   x->l->apply(l, y);","  //   x->r->apply(y + 1, r);","  //   x->x = 0;","  // }","}","","namespace {","","void build(Node* x, int l, int r) {","  if (l == r) {","    return;","  }","  int y = (l + r) >> 1;","  x->l = new Node;","  x->r = new Node;","  build(x->l, l, y);","  build(x->r, y + 1, r);","  pull(x);","}","","template <typename T>","void build(Node* x, int l, int r, const vector<T>& v) {","  if (l == r) {","    x->apply(l, r, v[l]);","    return;","  }","  int y = (l + r) >> 1;","  x->l = new Node;","  x->r = new Node;","  build(x->l, l, y, v);","  build(x->r, y + 1, r, v);","  pull(x);","}","","Node get(Node* x, int l, int r, int ll, int rr) {","  if (ll <= l && r <= rr) {","    return *x;","  }","  int y = (l + r) >> 1;","  push(x, l, r);","  Node res{};","  if (rr <= y) {","    res = get(x->l, l, y, ll, rr);","  } else if (ll > y) {","    res = get(x->r, y + 1, r, ll, rr);","  } else {","    unite(res, get(x->l, l, y, ll, rr), get(x->r, y + 1, r, ll, rr));","  }","  pull(x);","  return res;","}","","template <typename... T>","void modify(Node* x, int l, int r, int ll, int rr, Node* n, const T&... v) {","  if (ll <= l && r <= rr) {","    n->apply(l, r, v...);","    return;","  }","  int y = (l + r) >> 1;","  push(x, l, r);","  push(n, l, r);","  if (ll <= y) {","    n->l = copy(x->l);","    modify(x->l, l, y, ll, rr, n->l, v...);","  }","  if (rr > y) {","    n->r = copy(x->r);","    modify(x->r, y + 1, r, ll, rr, n->r, v...);","  }","  // pull(x);  // needed?","  pull(n);","}","","int find_first_knowingly(Node* x, int l, int r, const function<bool(const Node* const)>& f) {","  if (l == r) {","    return l;","  }","  int y = (l + r) >> 1;","  push(x, l, r);","  int res;","  if (f(x->l)) {","    res = find_first_knowingly(x->l, l, y, f);","  } else {","    res = find_first_knowingly(x->r, y + 1, r, f);","  }","  pull(x);","  return res;","}","","int find_first(Node* x, int l, int r, int ll, int rr, const function<bool(const Node* const)>& f) {","  if (ll <= l && r <= rr) {","    if (f(x)) {","      return find_first_knowingly(x, l, r, f);","    }","    return -1;","  }","  int y = (l + r) >> 1;","  push(x, l, r);","  int res = -1;","  if (ll <= y) {","    res = find_first(x->l, l, y, ll, rr, f);","  }","  if (res == -1 && rr > y) {","    res = find_first(x->r, y + 1, r, ll, rr, f);","  }","  pull(x);","  return res;","}","","int find_last_knowingly(Node* x, int l, int r, const function<bool(const Node* const)>& f) {","  if (l == r) {","    return l;","  }","  int y = (l + r) >> 1;","  push(x, l, r);","  int res;","  if (f(x->r)) {","    res = find_last_knowingly(x->r, y + 1, r, f);","  } else {","    res = find_last_knowingly(x->l, l, y, f);","  }","  pull(x);","  return res;","}","","int find_last(Node* x, int l, int r, int ll, int rr, const function<bool(const Node* const)>& f) {","  if (ll <= l && r <= rr) {","    if (f(x)) {","      return find_last_knowingly(x, l, r, f);","    }","    return -1;","  }","  int y = (l + r) >> 1;","  push(x, l, r);","  int res = -1;","  if (rr > y) {","    res = find_last(x->r, y + 1, r, ll, rr, f);","  }","  if (res == -1 && ll <= y) {","    res = find_last(x->l, l, y, ll, rr, f);","  }","  pull(x);","  return res;","}","","}  // namespace","","Node* build(int n) {","  Node* root = new Node;","  build(root, 0, n - 1);","  return root;","}","","template <typename T>","Node* build(const vector<T>& v) {","  int n = (int) v.size();","  Node* root = new Node;","  build(root, 0, n - 1, v);","  return root;","}","","Node get(Node* root, int n, int ll, int rr) {","  assert(0 <= ll && ll <= rr && rr < n);","  return get(root, 0, n - 1, ll, rr);","}","","Node get(Node* root, int n, int p) {","  assert(0 <= p && p < n);","  return get(root, 0, n - 1, p, p);","}","","template <typename... T>","Node* modify(Node* root, int n, int ll, int rr, const T&... v) {","  assert(0 <= ll && ll <= rr && rr < n);","  Node* new_root = copy(root);","  modify(root, 0, n - 1, ll, rr, new_root, v...);","  return new_root;","}","","int find_first(Node* root, int n, int ll, int rr, const function<bool(const Node* const)>& f) {","  assert(0 <= ll && ll <= rr && rr < n);","  return find_first(root, 0, n - 1, ll, rr, f);","}","","int find_last(Node* root, int n, int ll, int rr, const function<bool(const Node* const)>& f) {","  assert(0 <= ll && ll <= rr && rr < n);","  return find_last(root, 0, n - 1, ll, rr, f);","}","","void DebugTree(Node* v, int n) {","#ifdef _DEBUG","  for (int i = 0; i < n; i++) {","    Node nd = get(v, n, i);","    if (i > 0) {","      cerr << ' ';","    }","    // cerr << nd.sum;","  }","  cerr << '\\n';","#endif","}","","}  // namespace persistent_segtree","","using namespace persistent_segtree;"],
        "description": "Psegtree",
    }
    ,
    "Sliding Window": {
        "scope": "cpp",
        "prefix": "slidingwindow",
        "body": ["/*","Verification: none","","*/","","template <typename T, class F = function<bool(const T&, const T&)>>","vector<int> sliding_window(int n, const vector<T> &v, int k, const F &f) {","  assert(0 < k && k <= n);","  deque<int> q;","  vector<int> res(n - k + 1);","  for (int i = 0; i < n; i++) {","    if (i - k + 1 >= 0) {","      res[i - k + 1] = q.front();","      if (q.front() == i) {","        q.pop_front();","      }","    }","    while (!q.epmty() && f(v[i], v[q.back()])) {","      q.pop_back();","    }","    q.push_back(i);","  }","  return res;","}","","template <typename T, class F = function<bool(const T&, const T&)>>","vector<int> sliding_window(const vector<T> &v, int k, const F &f) {","  return sliding_window((int) v.size(), v, k, f);","}","","","/*","For sliding window minimum of vector<long long> v:","vector<int> swm = sliding_window(v, k, [](long long x, long long y) {","  return x < y;","});","","returns indices of the elements corresponding to the sliding window minimum,","breaking ties by smaller index","*/"],
        "description": "Sliding Window",
    }
    ,
    "Treap": {
        "scope": "cpp",
        "prefix": "treap",
        "body": ["mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());","","class Node {"," public:","  int id;","  Node* l;","  Node* r;","  Node* p;","  bool rev;","  int sz;","  // declare extra variables:","  int P;","  $1","","  Node(int _id$2) : id(_id) {","    l = r = p = nullptr;","    rev = false;","    sz = 1;","    // init extra variables:","    P = rng();","  }","","  void unsafe_reverse() {","    rev ^= 1;","    swap(l, r);","    pull();","  }","","  // apply changes:","  void unsafe_apply() {","","  }","","  void push() {","    if (rev) {","      if (l != nullptr) {","        l->unsafe_reverse();","      }","      if (r != nullptr) {","        r->unsafe_reverse();","      }","      rev = 0;","    }","    // now push everything else:","","  }","","  void pull() {","    sz = 1;","    // now init from self:","    ","    if (l != nullptr) {","      l->p = this;","      sz += l->sz;","      // now pull from l:","      ","    }","    if (r != nullptr) {","      r->p = this;","      sz += r->sz;","      // now pull from r:","      ","    }","  }","};","","void debug_node(Node* v, string pref = \"\") {","#ifdef _DEBUG","  if (v != nullptr) {","    debug_node(v->r, pref + \" \");","    cerr << pref << \"-\" << \" \" << v->id << '\\n';","    debug_node(v->l, pref + \" \");","  } else {","    cerr << pref << \"-\" << \" \" << \"nullptr\" << '\\n';","  }","  if (pref == \"\") {","    cerr << '\\n';","  }","#endif","}","","namespace treap {","","pair<Node*, int> find(Node* v, const function<int(Node*)>& go_to) {","  // go_to returns: 0 -- found; -1 -- go left; 1 -- go right","  // find returns the last vertex on the descent and its go_to","  if (v == nullptr) {","    return {nullptr, 0};","  }","  int dir;","  while (true) {","    v->push();","    dir = go_to(v);","    if (dir == 0) {","      break;","    }","    Node* u = (dir == -1 ? v->l : v->r);","    if (u == nullptr) {","      break;","    }","    v = u;","  }","  return {v, dir};","}","","Node* get_leftmost(Node* v) {","  return find(v, [&](Node*) { return -1; }).first;","}","","Node* get_rightmost(Node* v) {","  return find(v, [&](Node*) { return 1; }).first;","}","","Node* get_kth(Node* v, int k) {  // 0-indexed","  pair<Node*, int> p = find(v, [&](Node* u) {","    if (u->l != nullptr) {","      if (u->l->sz > k) {","        return -1;","      }","      k -= u->l->sz;","    }","    if (k == 0) {","      return 0;","    }","    k--;","    return 1;","  });","  return (p.second == 0 ? p.first : nullptr);","}","","int get_position(Node* v) {  // 0-indexed","  int k = (v->l != nullptr ? v->l->sz : 0);","  while (v->p != nullptr) {","    if (v == v->p->r) {","      k++;","      if (v->p->l != nullptr) {","        k += v->p->l->sz;","      }","    }","    v = v->p;","  }","  return k;","}","","Node* get_bst_root(Node* v) {","  while (v->p != nullptr) {","    v = v->p;","  }","  return v;","}","","pair<Node*, Node*> split(Node* v, const function<bool(Node*)>& is_right) {","  if (v == nullptr) {","    return {nullptr, nullptr};","  }","  v->push();","  if (is_right(v)) {","    pair<Node*, Node*> p = split(v->l, is_right);","    if (p.first != nullptr) {","      p.first->p = nullptr;","    }","    v->l = p.second;","    v->pull();","    return {p.first, v};","  } else {","    pair<Node*, Node*> p = split(v->r, is_right);","    v->r = p.first;","    if (p.second != nullptr) {","      p.second->p = nullptr;","    }","    v->pull();","    return {v, p.second};","  }","}","","pair<Node*, Node*> split_leftmost_k(Node* v, int k) {","  return split(v, [&](Node* u) {","    int left_and_me = (u->l != nullptr ? u->l->sz : 0) + 1;","    if (k >= left_and_me) {","      k -= left_and_me;","      return false;","    }","    return true;","  });","}","","Node* merge(Node* v, Node* u) {","  if (v == nullptr) {","    return u;","  }","  if (u == nullptr) {","    return v;","  }","  if (v->P > u->P) {","    //    if (rng() % (v->sz + u->sz) < (unsigned int) v->sz) {","    v->push();","    v->r = merge(v->r, u);","    v->pull();","    return v;","  } else {","    u->push();","    u->l = merge(v, u->l);","    u->pull();","    return u;","  }","}","","int count_left(Node* v, const function<bool(Node*)>& is_right) {","  if (v == nullptr) {","    return 0;","  }","  v->push();","  if (is_right(v)) {","    return count_left(v->l, is_right);","  }","  return (v->l != nullptr ? v->l->sz : 0) + 1 + count_left(v->r, is_right);","}","","Node* add(Node* r, Node* v, const function<bool(Node*)>& go_left) {","  pair<Node*, Node*> p = split(r, go_left);","  return merge(p.first, merge(v, p.second));","}","","Node* remove(Node* v) {  // returns the new root","  v->push();","  Node* x = v->l;","  Node* y = v->r;","  Node* p = v->p;","  v->l = v->r = v->p = nullptr;","  v->push();","  v->pull();  // now v might be reusable...","  Node* z = merge(x, y);","  if (p == nullptr) {","    if (z != nullptr) {","      z->p = nullptr;","    }","    return z;","  }","  if (p->l == v) {","    p->l = z;","  }","  if (p->r == v) {","    p->r = z;","  }","  while (true) {","    p->push();","    p->pull();","    if (p->p == nullptr) {","      break;","    }","    p = p->p;","  }","  return p;","}","","Node* next(Node* v) {","  if (v->r == nullptr) {","    while (v->p != nullptr && v->p->r == v) {","      v = v->p;","    }","    return v->p;","  }","  v->push();","  v = v->r;","  while (v->l != nullptr) {","    v->push();","    v = v->l;","  }","  return v;","}","","Node* prev(Node* v) {","  if (v->l == nullptr) {","    while (v->p != nullptr && v->p->l == v) {","      v = v->p;","    }","    return v->p;","  }","  v->push();","  v = v->l;","  while (v->r != nullptr) {","    v->push();","    v = v->r;","  }","  return v;","}","","int get_size(Node* v) {","  return (v != nullptr ? v->sz : 0);","}","","template <typename... T>","void apply(Node* v, T... args) {","  v->unsafe_apply(args...);","}","","void reverse(Node* v) {","  v->unsafe_reverse();","}","","}  // namespace treap","","using namespace treap;"],
        "description": "Treap",
    }
    ,
    "Segtree": {
        "scope": "cpp",
        "prefix": "segtree",
        "body": ["class SegTree {"," public:","  struct Node {","    // declare variables with initial value (for leaves)","    $1","","    void apply(int l, int r, $2) {","      $3","    }","  ","    inline void push_onto(int l, int r, Node& a, Node& b) {","      int y = (l + r) >> 1;","      ${4:if (add != 0) {","        a.apply(l, y, add);","        b.apply(y + 1, r, add);","        add = 0;","      \\}}","    }","  };",""," private:","  static inline Node unite(const Node& a, const Node& b) {","    Node res;","    $5","    return res;","  }","  ","  const int n;","  vector<Node> tree;","  ","  inline void push(int x, int l, int r) {","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    tree[x].push_onto(l, r, tree[x + 1], tree[z]);","  }","","  inline void pull(int x, int z) {","    tree[x] = unite(tree[x + 1], tree[z]);","  }","","  void build(int x, int l, int r) {","    if (l == r) {","      return;","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    build(x + 1, l, y);","    build(z, y + 1, r);","    pull(x, z);","  }","","  template <typename T>","  void build(int x, int l, int r, const vector<T>& v) {","    if (l == r) {","      tree[x].apply(l, r, v[l]);","      return;","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    build(x + 1, l, y, v);","    build(z, y + 1, r, v);","    pull(x, z);","  }","","  Node get(int x, int l, int r, int ll, int rr) {","    if (ll <= l && r <= rr) {","      return tree[x];","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    push(x, l, r);","    Node res;","    if (rr <= y) {","      res = get(x + 1, l, y, ll, rr);","    } else if (ll > y) {","      res = get(z, y + 1, r, ll, rr);","    } else {","      res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));","    }","    pull(x, z);","    return res;","  }","","  template <typename... T>","  void modify(int x, int l, int r, int ll, int rr, const T&... v) {","    if (ll <= l && r <= rr) {","      tree[x].apply(l, r, v...);","      return;","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    push(x, l, r);","    if (ll <= y) {","      modify(x + 1, l, y, ll, rr, v...);","    }","    if (rr > y) {","      modify(z, y + 1, r, ll, rr, v...);","    }","    pull(x, z);","  }","","  int find_first_knowingly(int x, int l, int r, const function<bool(const Node&)>& f) {","    if (l == r) {","      return l;","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    push(x, l, r);","    int res;","    if (f(tree[x + 1])) {","      res = find_first_knowingly(x + 1, l, y, f);","    } else {","      res = find_first_knowingly(z, y + 1, r, f);","    }","    pull(x, z);","    return res;","  }","","  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const Node&)>& f) {","    if (ll <= l && r <= rr) {","      if (!f(tree[x])) {","        return -1;","      }","      return find_first_knowingly(x, l, r, f);","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    push(x, l, r);","    int res = -1;","    if (ll <= y) {","      res = find_first(x + 1, l, y, ll, rr, f);","    }","    if (rr > y && res == -1) {","      res = find_first(z, y + 1, r, ll, rr, f);","    }","    pull(x, z);","    return res;","  }","","  int find_last_knowingly(int x, int l, int r, const function<bool(const Node&)>& f) {","    if (l == r) {","      return l;","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    push(x, l, r);","    int res;","    if (f(tree[z])) {","      res = find_last_knowingly(z, y + 1, r, f);","    } else {","      res = find_last_knowingly(x + 1, l, y, f);","    }","    pull(x, z);","    return res;","  }","","  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const Node&)>& f) {","    if (ll <= l && r <= rr) {","      if (!f(tree[x])) {","        return -1;","      }","      return find_last_knowingly(x, l, r, f);","    }","    int y = (l + r) >> 1;","    int z = x + ((y - l + 1) << 1);","    push(x, l, r);","    int res = -1;","    if (rr > y) {","      res = find_last(z, y + 1, r, ll, rr, f);","    }","    if (ll <= y && res == -1) {","      res = find_last(x + 1, l, y, ll, rr, f);","    }","    pull(x, z);","    return res;","  }","  "," public:","  SegTree(int _n) : n(_n), tree(2 * n - 1) {","    assert(n > 0);","    build(0, 0, n - 1);","  }","","  template <typename T>","  SegTree(const vector<T>& v) : n(v.size()), tree(2 * n - 1) {","    assert(n > 0);","    build(0, 0, n - 1, v);","  }","","  Node get(int ll, int rr) {","    assert(0 <= ll && ll <= rr && rr < n);","    return get(0, 0, n - 1, ll, rr);","  }","","  Node get(int p) {","    assert(0 <= p && p < n);","    return get(0, 0, n - 1, p, p);","  }","","  // due to variadic templates, we cannot also have modify(int p, const T&... v)","  template <typename... T>","  void modify(int ll, int rr, const T&... v) {","    assert(0 <= ll && ll <= rr && rr < n);","    modify(0, 0, n - 1, ll, rr, v...);","  }","","  // find_first and find_last call all FALSE elements","  // to the left (right) of the sought position exactly once","","  int find_first(int ll, int rr, const function<bool(const Node&)>& f) {","    assert(0 <= ll && ll <= rr && rr < n);","    return find_first(0, 0, n - 1, ll, rr, f);","  }","","  int find_last(int ll, int rr, const function<bool(const Node&)>& f) {","    assert(0 <= ll && ll <= rr && rr < n);","    return find_last(0, 0, n - 1, ll, rr, f);","  }","};"],
        "description": "Segtree",
    }
    ,
    "Segtree Iterative": {
        "scope": "cpp",
        "prefix": "segtreeiterative",
        "body": ["// point updates and range queries of an associative `unite` function","// TODO: support range updates (lazy propagation) somehow?","","class SegTree {"," public:","  struct Node {","    // declare variables with initial value (for leaves)","    $1","","    void apply(int p, $2) {","      $3","    }","  };","","  static inline Node unite(const Node& a, const Node& b) {","    Node res;","    $4","    return res;","  }","  "," private:","  // note: with this \"multiple perfect binary trees\" implementation that","  // only uses 2*n nodes, st.tree[1] does not always contain the answer","  // to a query on the whole tree.","  // see https://codeforces.com/blog/entry/18051","  const int n;","  vector<Node> tree;","","  inline void pull(int x) {","    tree[x] = unite(tree[2 * x], tree[2 * x + 1]);","  }",""," public:  ","  inline Node get(int ll, int rr) {","    assert(0 <= ll && ll <= rr && rr < n);","    int x = ll + n;","    int y = rr + n;","    Node L, R;","    bool usedL = false;","    bool usedR = false;","    while (x <= y) {","      if (x % 2 == 1) {","        L = (usedL ? unite(L, tree[x]) : tree[x]);","        usedL = true;","        ++x;","      }","      if (y % 2 == 0) {","        R = (usedR ? unite(tree[y], R) : tree[y]);","        usedR = true;","        --y;","      }","      x >>= 1;","      y >>= 1;","    }","    if (!usedL) {","      return R;","    }","    if (!usedR) {","      return L;","    }","    return unite(L, R);","  }","  ","  inline Node get(int p) {","    return tree[p + n];","  }","  ","  template <typename ...T>","  inline void modify(int p, const T&... v) {","    assert(0 <= p && p < n);","    int x = p + n;","    tree[x].apply(p, v...);","    for (x >>= 1; x >= 1; x >>= 1) {","      pull(x);","    }","  }","  ","  SegTree(int _n) : n(_n), tree(2 * n) {","    assert(n > 0);","    for (int x = n - 1; x >= 1; x--) {","      pull(x);","    }","  }","  ","  template <typename T>","  SegTree(const vector<T>& v) : n(v.size()), tree(2 * n) {","    assert(n > 0);","    for (int i = 0; i < n; i++) {","      tree[i + n].apply(i, v[i]);","    }","    for (int x = n - 1; x >= 1; x--) {","      pull(x);","    }","  }","};"],
        "description": "Segtree Iterative",
    }
    ,
    "Fenwick": {
        "scope": "cpp",
        "prefix": "fenwick",
        "body": ["template <typename T>","class Fenwick {"," public:","  const int n;","  const int max_power; // smallest power of 2 larger than n","  vector<T> tree;","","  Fenwick(int _n) : n(_n), max_power(1 << (32 - __builtin_clz(n))), tree(n) {","    assert(n > 0);","  }","","  T get(int x) const {","    assert(-1 <= x && x < n);","    T res{};","    while (x >= 0) {","      res += tree[x];","      x = (x & (x + 1)) - 1;","    }","    return res;","  }","","  void modify(int x, T v) {","    assert(0 <= x && x < n);","    while (x < n) {","      tree[x] += v;","      x |= (x + 1);","    }","  }","","  /*","  returns the first index p such that sum(a[0..p]) >= t","  returns -1 if the empty sum works and n if no sum works","","  NOTE: it only makes sense to use this function when all values","  in the array we are maintaining are non-negative;","  this method allows such queries in O(log(n)) instead of O(log^2(n))","  */","  int lower_bound(T t) const {","    if (t <= 0) {","      return -1;","    }","    int k = -1;","    T sum = 0;","    for (int p = max_power; p > 0; p >>= 1) {","      if (k + p < n && sum + tree[k + p] < t) {","        k += p;","        sum += tree[k];","      }","    }","    return k + 1;","  }","};"],
        "description": "Fenwick",
    }
    ,
    "Ptrie": {
        "scope": "cpp",
        "prefix": "ptrie",
        "body": ["/*","Verification:","https://dmoj.ca/submission/2001174","*/","","","class PTrie {","public:","  class Node {","  public:","    int cnt = 0; // number of ends in subtree","    int end = 0;","    unordered_map<char, Node*> c;","","    void clone(Node* other) {","      cnt = other->cnt;","      end = other->end;","      c = other->c;","    }","  };","","  vector<Node*> root;","","  PTrie() {","    root.push_back(new Node());","  }","","  void insert(string s) {","    Node* v = root.back();","    Node* nv = new Node();","    root.push_back(nv);","    for (char c : s) {","      if (v) {","        nv->clone(v);","        v = (v->c.count(c) ? v->c[c] : NULL);","      }","      nv->cnt++;","      nv = (nv->c[c] = new Node());","    }","    if (v) { // don't forget this part!","      nv->clone(v);","    }","    nv->cnt++;","    nv->end++;","  }","","  int get_cnt(int k, string s) {","    // number of occurrences of s in the dictionary","    assert(0 <= k && k < (int) root.size());","    Node* v = root[k];","    for (char c : s) {","      if (!v->c.count(c)) {","        return 0;","      }","      v = v->c[c];","    }","    return v->end;","  }","","  int get_cnt_prefixed_by(int k, string s) {","    assert(0 <= k && k < (int) root.size());","    Node* v = root[k];","    for (char c : s) {","      if (!v->c.count(c)) {","        return 0;","      }","      v = v->c[c];","    }","    return v->cnt;","  }","","  int get_cnt_prefix_of(int k, string s) {","    assert(0 <= k && k < (int) root.size());","    Node* v = root[k];","    int res = 0;","    for (char c : s) {","      res += v->end;","      if (!v->c.count(c)) {","        v = NULL;","        break;","      }","      v = v->c[c];","    }","    if (v) {","      res += v->end;","    }","    return res;","  }","};"],
        "description": "Ptrie",
    }
    ,
    "Segtree Dynamic": {
        "scope": "cpp",
        "prefix": "segtreedynamic",
        "body": ["class BigSegTree {"," public:","  struct Node {","    // declare variables with initial value (for leaves)","    $1","","    void apply(int l, int r, $2) {","      $3","    }","    ","    void push_onto(int l, int r, Node& a, Node& b) {","      assert(l != r);","      int y = (l + r) >> 1;","      // if (add != 0) {","      //   a.apply(l, y, add);","      //   b.apply(y + 1, r, add);","      //   add = 0;","      // }","      $4","    }","  };","  "," private:","  static inline Node unite(const Node& a, const Node& b) {","    Node res;","    $5","    return res;","  }","  ","  const int n;","  vector<Node> tree;","  vector<int> idL;","  vector<int> idR;","  ","  int make_node() {","    int id = tree.size();","    tree.emplace_back();","    idL.push_back(-1);","    idR.push_back(-1);","    return id;","  }","  ","  void ensure_children(int x) {","    if (idL[x] == -1) {","      idL[x] = make_node();","    }","    if (idR[x] == -1) {","      idR[x] = make_node();","    }","  }","  ","  void push(int x, int l, int r) {","    ensure_children(x);","    tree[x].push_onto(l, r, tree[idL[x]], tree[idR[x]]);","  }","  ","  void pull(int x) {","    assert(idL[x] != -1 && idR[x] != -1);","    tree[x] = unite(tree[idL[x]], tree[idR[x]]);","  }","  ","  // no build function","  ","  Node get(int x, int l, int r, int ll, int rr) {","    if (ll <= l && r <= rr) {","      return tree[x];","    }","    int y = (l + r) >> 1;","    push(x, l, r);","    Node res;","    if (rr <= y) {","      res = get(idL[x], l, y, ll, rr);","    } else if (ll > y) {","      res = get(idR[x], y + 1, r, ll, rr);","    } else {","      res = unite(get(idL[x], l, y, ll, rr), get(idR[x], y + 1, r, ll, rr));","    }","    pull(x);","    return res;","  }","  ","  template<typename... T>","  void modify(int x, int l, int r, int ll, int rr, const T&... v) {","    if (ll <= l && r <= rr) {","      tree[x].apply(l, r, v...);","      return;","    }","    int y = (l + r) >> 1;","    push(x, l, r);","    if (ll <= y) {","      modify(idL[x], l, y, ll, rr, v...);","    }","    if (rr > y) {","      modify(idR[x], y + 1, r, ll, rr, v...);","    }","    pull(x);","  }","  ","  // TODO: add find_first stuff?",""," public:","  BigSegTree(int _n) : n(_n) {","    assert(n > 0);","    make_node(); // make the root","  }","","  Node get(int ll, int rr) {","    assert(0 <= ll && ll <= rr && rr < n);","    return get(0, 0, n - 1, ll, rr);","  }","","  Node get(int p) {","    assert(0 <= p && p < n);","    return get(0, 0, n - 1, p, p);","  }","  ","  // due to variadic templates, we cannot also have modify(int p, const T&... v)","  template <typename... T>","  void modify(int ll, int rr, const T&... v) {","    assert(0 <= ll && ll <= rr && rr < n);","    modify(0, 0, n - 1, ll, rr, v...);","  }","};"],
        "description": "Segtree Dynamic",
    }
    ,
    "Dsu": {
        "scope": "cpp",
        "prefix": "dsu",
        "body": ["class Dsu {"," public:","  int n;","  vector<int> p;","  vector<int> sz;  // get that inverse Ackermann time complexity","  vector<int> v;   // version","  int comps;","  int ver;","","  Dsu(int _n) : n(_n) {","    p.resize(n, -1);","    sz.resize(n, 1);","    v.resize(n, 0);","    comps = n;","    ver = 0;","  }","","  inline int get(int x) {","    if (v[x] != ver) {","      p[x] = -1;","      sz[x] = 1;","      v[x] = ver;","    }","    return (p[x] == -1 ? x : (p[x] = get(p[x])));","  }","","  inline bool same(int x, int y) {","    return (get(x) == get(y));","  }","","  inline bool unite(int x, int y) {","    x = get(x);","    y = get(y);","    if (x == y) {","      return false;","    }","    if (sz[x] > sz[y]) {","      swap(x, y);","    }","    p[x] = y;","    sz[y] += sz[x];","    --comps;","    return true;","  }","","  inline void reset() {","    comps = n;","    ++ver;","  }","};"],
        "description": "Dsu",
    }
    ,
    "Fenwick Range Add": {
        "scope": "cpp",
        "prefix": "fenwickrangeadd",
        "body": ["template <typename T>","class FenwickRangeAdd {"," private:","  const int n;","  const int max_power; // smallest power of 2 larger than n","  vector<T> tree0;","  vector<T> tree1;","","  inline void _modify(vector<T>& tree, int x, T v) {","    assert(0 <= x && x < n);","    while (x < n) {","      tree[x] += v;","      x |= (x + 1);","    }","  }",""," public:","  FenwickRangeAdd(int _n) : n(_n), tree0(n), tree1(n), max_power(1 << (32 - __builtin_clz(n))) {","    assert(n > 0);","  }","","  void modify(int L, int R, T v) {","    _modify(tree1, L, v);","    _modify(tree1, R + 1, -v);","    _modify(tree0, L, -(L - 1) * v);","    _modify(tree0, R + 1, R * v);","  }","","  T get(int x) const {","    assert(-1 <= x && x < n);","    int i = x;","    T a{}, b{};","    while (x >= 0) {","      a += tree1[x];","      b += tree0[x];","      x = (x & (x + 1)) - 1;","    }","    return a * i + b; // watch out for overflow","  }","","  /*","  returns the first index p such that sum(a[0..p]) >= t","  returns -1 if the empty sum works and n if no sum works","","  NOTE: it only makes sense to use this function when all values","  in the array we are maintaining are non-negative;","  this method allows such queries in O(log(n)) instead of O(log^2(n))","  */","  int lower_bound(T t) const {","    if (t <= 0) {","      return -1;","    }","    int k = -1;","    T a = 0, b = 0;","    for (int p = max_power; p > 0; p >>= 1) {","      if (k + p < n && (k + p) * (a + tree1[k + p]) + (b + tree0[k + p]) < t) {","        k += p;","        a += tree1[k];","        b += tree0[k];","      }","    }","    return k + 1;","  }","};"],
        "description": "Fenwick Range Add",
    }
    ,
    "Dsu Undo": {
        "scope": "cpp",
        "prefix": "dsuundo",
        "body": ["class Dsu {"," public:","  int n;","  vector<int> p;","  vector<int> sz;","  vector<int> v;  // version","  vector<pair<int, int>> ops;","  int comps;","  int ver;","","  Dsu(int _n) : n(_n) {","    p.resize(n, -1);","    sz.resize(n, 1);","    v.resize(n, 0);","    comps = n;","    ver = 0;","  }","","  inline int get(int x) {","    while (true) {","      if (v[x] != ver) {","        p[x] = -1;","        sz[x] = 1;","        v[x] = ver;","      }","      if (p[x] == -1) {","        break;","      }","      x = p[x];","    }","    return x;","  }","","  inline bool same(int x, int y) {","    return (get(x) == get(y));","  }","","  inline bool unite(int x, int y) {","    x = get(x);","    y = get(y);","    if (x == y) {","      return false;","    }","    if (sz[x] > sz[y]) {","      swap(x, y);","    }","    p[x] = y;","    sz[y] += sz[x];","    ops.emplace_back(x, y);","    --comps;","    return true;","  }","","  inline void undo() {","    // only undoes unite(x, y) operations that returned true","    assert(!ops.empty());","    int x, y;","    tie(x, y) = ops.back();","    ops.pop_back();","    sz[y] -= sz[x];","    p[x] = -1;","    ++comps;","  }","  ","  void reset() {","    ops.clear();","    comps = n;","    ++ver;","  }","};"],
        "description": "Dsu Undo",
    }
    ,
    "Bst Node": {
        "scope": "cpp",
        "prefix": "bstnode",
        "body": ["class Node {"," public:","  int id;","  Node* l;","  Node* r;","  Node* p;","  bool rev;","  int sz;","  // declare extra variables:","  $1","","  Node(int _id$2) : id(_id) {","    l = r = p = nullptr;","    rev = false;","    sz = 1;","    // init extra variables:","    $3","  }","","  void unsafe_reverse() {","    rev ^= 1;","    swap(l, r);","    pull();","  }","","  // apply changes:","  void unsafe_apply() {","","  }","","  void push() {","    if (rev) {","      if (l != nullptr) {","        l->unsafe_reverse();","      }","      if (r != nullptr) {","        r->unsafe_reverse();","      }","      rev = 0;","    }","    // now push everything else:","","  }","","  void pull() {","    sz = 1;","    // now init from self:","    $4","    if (l != nullptr) {","      l->p = this;","      sz += l->sz;","      // now pull from l:","      $5","    }","    if (r != nullptr) {","      r->p = this;","      sz += r->sz;","      // now pull from r:","      $6","    }","  }","};","","void debug_node(Node* v, string pref = \"\") {","#ifdef _DEBUG","  if (v != nullptr) {","    debug_node(v->r, pref + \" \");","    cerr << pref << \"-\" << \" \" << v->id << '\\n';","    debug_node(v->l, pref + \" \");","  } else {","    cerr << pref << \"-\" << \" \" << \"nullptr\" << '\\n';","  }","#endif","}"],
        "description": "Bst Node",
    }
    ,
    "Histogram": {
        "scope": "cpp",
        "prefix": "histogram",
        "body": ["template <typename T>","class histogram {","","private:","  int n;","  vector<T> hist;","","public:","  histogram(vector<T> _hist) : hist(_hist) {","    n = hist.size();","  }","","  T area_max_rect() {","    T ans = -1;","    int ptr = 0;","    stack<int> s;","    while (ptr < n) {","      if (s.empty() || hist[ptr] >= hist[s.top()]) {","        s.push(ptr++);","        continue;","      }","      T tp = s.top(); s.pop();","      if (!s.empty()) {","        ans = max(ans, hist[tp] * (ptr - s.top() - 1));","      }","      else {","        ans = max(ans, hist[tp] * ptr);","      }","    }","    while (!s.empty()) {","      T tp = s.top(); s.pop();","      if (!s.empty()) {","        ans = max(ans, hist[tp] * (ptr - s.top() - 1));","      }","      else {","        ans = max(ans, hist[tp] * ptr);","      }","    }","    return ans;","  }","};"],
        "description": "Histogram",
    }
    ,
    "Dynamic Hull": {
        "scope": "cpp",
        "prefix": "dynamichull",
        "body": ["namespace dynamic_hull {","","const long long INF = (long long) 4e18;","","struct Line {","  long long m;  // slope, or the x-coordinate of the query if is_query == true","  long long b;","  mutable long long x;  // x-coordinate of intersection with line to the right","  bool is_query;","","  Line(long long _m, long long _b, bool _is_query = false) {","    m = _m;","    b = _b;","    is_query = _is_query;","  }","","  bool operator<(const Line& rhs) const {","    if (!rhs.is_query) {","      if (m != rhs.m) {","        return m < rhs.m;","      }","      return b < rhs.b;","    }","    return x < rhs.m;","  }","};","","long long floor_div(long long a, long long b) {","  long long res = a / b;","  if (a < 0 && res * b != a) {","    res -= 1;","  }","  return res;","}","","long long intersect(const Line& k, const Line& l) {","  return floor_div(k.b - l.b, l.m - k.m);","}","","class MaxHull : public multiset<Line> {","  bool bad(const_iterator y) const {","    auto z = next(y);","    if (z == end()) {","      return false;","    }","    if (z->m == y->m) {","      return true;","    }","    if (y == begin()) {","      return false;","    }","    auto x = prev(y);","    if (x->m == y->m) {","      return false;","    }","    return intersect(*x, *y) >= intersect(*y, *z);","  }",""," public:","  void insert_line(long long m, long long b) {","    auto y = insert(Line(m, b));","    if (bad(y)) {","      erase(y);","      return;","    }","    while (next(y) != end() && bad(next(y))) {","      erase(next(y));","    }","    while (y != begin() && bad(prev(y))) {","      erase(prev(y));","    }","    if (y != begin()) {","      auto x = prev(y);","      x->x = intersect(*x, *y);","    }","    auto z = next(y);","    if (z != end()) {","      y->x = intersect(*y, *z);","    } else {","      y->x = INF;","    }","  }","","  void insert_line(const Line& line) {","    insert_line(line.m, line.b);","  }","","  long long query(long long x) const {","    assert(!empty());","    assert(INF >= x);","    auto l = *lower_bound(Line(x, -1, true));","    return l.m * x + l.b;","  }","};","","}  // namespace convex_hull","","using namespace dynamic_hull;"],
        "description": "Dynamic Hull",
    }
    ,
    "Link Cut Tree": {
        "scope": "cpp",
        "prefix": "linkcuttree",
        "body": ["class Node {"," public:","  int id;","  Node* l;","  Node* r;","  Node* p;","  bool rev;","  int sz;","  // declare extra variables:","","  Node(int _id) {","    id = _id;","    l = r = p = NULL;","    rev = false;","    sz = 1;","    // init extra variables:","  }","","  void unsafe_reverse() {","    rev ^= 1;","    swap(l, r);","    pull();","  }","","  // apply changes:","  void unsafe_apply() {","  }","","  void push() {","    if (rev) {","      if (l != NULL) {","        l->unsafe_reverse();","      }","      if (r != NULL) {","        r->unsafe_reverse();","      }","      rev = 0;","    }","    // now push everything else:","  }","","  void pull() {","    sz = 1;","    // now init from self:","","    if (l != NULL) {","      l->p = this;","      sz += l->sz;","      // now pull from l:","    }","    if (r != NULL) {","      r->p = this;","      sz += r->sz;","      // now pull from r:","    }","  }","};","","namespace splay_tree {","","bool is_bst_root(Node* v) {","  if (v == NULL) {","    return false;","  }","  return (v->p == NULL || (v->p->l != v && v->p->r != v));","}","","void rotate(Node* v) {","  Node* u = v->p;","  assert(u != NULL);","  u->push();","  v->push();","  if (v == u->l) {","    u->l = v->r;","    v->r = u;","  } else {","    u->r = v->l;","    v->l = u;","  }","  v->p = u->p;","  if (v->p != NULL) {","    if (v->p->l == u) {","      v->p->l = v;","    }","    if (v->p->r == u) {","      v->p->r = v;","    }","  }","  u->pull();","  v->pull();","}","","void splay(Node* v) {","  if (v == NULL) {","    return;","  }","  while (!is_bst_root(v)) {","    Node* u = v->p;","    if (!is_bst_root(u)) {","      if ((u->l == v) ^ (u->p->l == u)) {","        rotate(v);","      } else {","        rotate(u);","      }","    }","    rotate(v);","  }","}","","pair<Node*, int> find(Node* v, const function<int(Node*)>& go_to) {","  // go_to returns: 0 -- found; -1 -- go left; 1 -- go right","  if (v == NULL) {","    return {NULL, 0};","  }","  splay(v);","  int dir;","  while (true) {","    v->push();","    dir = go_to(v);","    if (dir == 0) {","      break;","    }","    Node* u = (dir == -1 ? v->l : v->r);","    if (u == NULL) {","      break;","    }","    v = u;","  }","  splay(v);","  return {v, dir};","}","","Node* get_leftmost(Node* v) {","  return find(v, [&](Node*) { return -1; }).first;","}","","Node* get_rightmost(Node* v) {","  return find(v, [&](Node*) { return 1; }).first;","}","","Node* get_kth(Node* v, int k) {  // 0-indexed","  pair<Node*, int> p = find(v, [&](node* u) {","    if (u->l != NULL) {","      if (u->sz > k) {","        return -1;","      }","      k -= u->sz;","    }","    if (k == 0) {","      return 0;","    }","    k--;","    return 1;","  });","  return (p.second == 0 ? p.first : NULL);","}","","int get_position(Node* v) {  // 0-indexed","  splay(v);","  return (v->l != NULL ? v->sz : 0);","}","","Node* get_bst_root(Node* v) {","  splay(v);","  return v;","}","","pair<Node*, Node*> split(Node* v, const function<bool(Node*)>& is_right) {","  if (v == NULL) {","    return {NULL, NULL};","  }","  pair<Node*, int> p = find(v, [&](node* u) { return is_right(u) ? -1 : 1; });","  v = p.first;","  v->push();","  if (p.second == -1) {","    Node* u = v->l;","    if (u == NULL) {","      return {NULL, v};","    }","    v->l = NULL;","    u->p = v->p;","    u = get_rightmost(u);","    v->p = u;","    v->pull();","    return {u, v};","  } else {","    Node* u = v->r;","    if (u == NULL) {","      return {v, NULL};","    }","    v->r = NULL;","    v->pull();","    return {v, u};","  }","}","","pair<Node*, Node*> split_leftmost_k(Node* v, int k) {","  return split(v, [&](Node* u) {","    int left_and_me = (u->l != NULL ? u->l->sz : 0) + 1;","    if (k >= left_and_me) {","      k -= left_and_me;","      return false;","    }","    return true;","  });","}","","Node* merge(Node* v, Node* u) {","  if (v == NULL) {","    return u;","  }","  if (u == NULL) {","    return v;","  }","  v = get_rightmost(v);","  assert(v->r == NULL);","  splay(u);","  v->push();","  v->r = u;","  v->pull();","  return v;","}","","Node* remove(Node* v) {","  splay(v);","  v->push();","  Node* x = v->l;","  Node* y = v->r;","  v->l = v->r = NULL;","  Node* z = merge(x, y);","  z->p = v->p;","  v->p = NULL;","  return z;","}","","int get_size(Node* v) {","  splay(v);","  return v->sz;","}","","template <typename... T>","void apply(Node* v, T... args) {","  splay(v);","  v->unsafe_apply(args...);","}","","void reverse(Node* v) {","  splay(v);","  v->unsafe_reverse();","}","","}  // namespace splay_tree","","using namespace splay_tree;","","template <bool rooted>","class LinkCutTree {"," public:","  int n;","  vector<Node*> nodes;","","  LinkCutTree(int _n) : n(_n) {","    nodes.resize(n);","    for (int i = 0; i < n; i++) {","      nodes[i] = new Node(i);","    }","  }","","  int add_node() {","    int id = (int) nodes.size();","    nodes.push_back(new Node(id));","    return id;","  }","","  void expose(Node* v) {","    Node* r = NULL;","    Node* u = v;","    while (u != NULL) {","      splay(u);","      u->push();","      u->r = r;","      u->pull();","      r = u;","      u = u->p;","    }","    splay(v);","    assert(v->p == NULL);","  }","","  int get_root(int i) {","    Node* v = nodes[i];","    expose(v);","    return get_leftmost(v)->id;","  }","","  bool link(int i, int j) {  // for rooted: (x, parent[x])","    if (i == j) {","      return false;","    }","    Node* v = nodes[i];","    Node* u = nodes[j];","    if (rooted) {","      splay(v);","      assert(v->p == NULL && v->l == NULL);  // must be a root","    } else {","      make_root(i);","    }","    expose(u);","    if (v->p != NULL) {","      return false;","    }","    v->p = u;","    return true;","  }","","  bool cut(int i, int j) {  // for rooted: (x, parent[x])","    if (i == j) {","      return false;","    }","    Node* v = nodes[i];","    Node* u = nodes[j];","    expose(u);","    splay(v);","    if (v->p != u) {","      if (rooted) {","        return false;","      }","      swap(u, v);","      expose(u);","      splay(v);","      if (v->p != u) {","        return false;","      }","    }","    v->p = NULL;","    return true;","  }","","  bool connected(int i, int j) {","    if (i == j) {","      return true;","    }","    Node* v = nodes[i];","    Node* u = nodes[j];","    expose(v);","    assert(v->p == NULL);","    expose(u);","    return v->p != NULL;","  }","","  int lca(int i, int j) {","    if (i == j) {","      return i;","    }","    Node* v = nodes[i];","    Node* u = nodes[j];","    expose(v);","    assert(v->p == NULL);","    expose(u);","    if (v->p == NULL) {","      return -1;","    }","    splay(v);","    if (v->p == NULL) {","      return v->id;","    }","    return v->p->id;","  }","","  bool is_ancestor(int i, int j) {","    if (i == j) {","      return true;","    }","    Node* v = nodes[i];","    Node* u = nodes[j];","    expose(u);","    assert(u->p == NULL);","    splay(v);","    return (v->p == NULL && u->p != NULL);","  }","","  void make_root(int i) {","    assert(!rooted);","    Node* v = nodes[i];","    expose(v);","    assert(v->r == NULL);","    reverse(v);","  }","","  Node* get_path_from_root(int i) {","    Node* v = nodes[i];","    expose(v);","    return v;","  }","","  template <typename... T>","  void apply(int i, T... args) {","    Node* v = nodes[i];","    splay_tree::apply(v, args...);","  }","};"],
        "description": "Link Cut Tree",
    }
    ,
    "Splay Tree": {
        "scope": "cpp",
        "prefix": "splaytree",
        "body": ["/*","Verification:","","","Link-cut tree, here I come!","*/","","namespace splay_tree {","","bool is_bst_root(Node* v) {","  if (v == nullptr) {","    return false;","  }","  return (v->p == nullptr || (v != v->p->l && v != v->p->r));","}","","void rotate(Node* v) {","  Node* p = v->p;","  assert(p != nullptr);","  p->push();","  v->push();","  // fix parent of v","  v->p = p->p;","  if (v->p != nullptr) {","    // in case of parent pointers for link cut tree; thus, we don't pull","    if (v->p->l == p) {","      v->p->l = v;","    }","    if (v->p->r == p) {","      v->p->r = v;","    }","    // don't call v->p->pull()!","  }","  if (v == p->l) {","    p->l = v->r;","    v->r = p;","  } else {","    p->r = v->l;","    v->l = p;","  }","  p->pull();  // pull from lower node first","  v->pull();","}","","void splay(Node* v) {","  if (v == nullptr) {","    return;","  }","  while (!is_bst_root(v)) {","    Node* p = v->p;","    if (!is_bst_root(p)) {","      if ((p->l == v) ^ (p->p->l == p)) {  // zig-zag case","        rotate(v);","      } else {  // zig-zig case","        rotate(p);","      }","    }","    rotate(v);","  }","}","","pair<Node*, int> find(Node* v, const function<int(Node*)>& go_to) {","  if (v == nullptr) {","    return {nullptr, 0};","  }","  splay(v);","  int dir;","  while (true) {","    v->push();","    dir = go_to(v);","    if (dir == 0) {","      break;","    }","    Node* u = (dir == -1 ? v->l : v->r);","    if (u == nullptr) {","      break;","    }","    v = u;","  }","  splay(v);","  return {v, dir};","}","","Node* get_leftmost(Node* v) {","  return find(v, [&](Node* u) { return -1; }).first;","}","","Node* get_rightmost(Node* v) {","  return find(v, [&](Node* u) { return 1; }).first;","}","","Node* get_kth(Node* v, int k) {","  pair<Node*, int> p = find(v, [&](Node* u) {","    if (u->l != nullptr) {","      if (u->l->sz > k) {","        return -1;","      }","      k -= u->l->sz;","    }","    if (k == 0) {","      return 0;","    }","    k--;","    return 1;","  });","  return (p.second == 0 ? p.first : nullptr);","}","","int get_position(Node* v) {","  assert(v != nullptr);","  splay(v);","  return (v->l != nullptr ? v->l->sz : 0);","}","","}  // namespace splay_tree","","using namespace splay_tree;"],
        "description": "Splay Tree",
    }
    ,
    "Dijkstra": {
        "scope": "cpp",
        "prefix": "dijkstra",
        "body": ["template <typename T>","vector<T> Dijkstra(const Graph<T>& g, int start) {","  assert(0 <= start && start < g.n);","  vector<T> dist(g.n, numeric_limits<T>::max());","  priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> s;","  dist[start] = 0;","  s.emplace(dist[start], start);","  while (!s.empty()) {","    T expected = s.top().first;","    int i = s.top().second;","    s.pop();","    if (dist[i] != expected) {","      continue;","    }","    for (int id : g.g[i]) {","      if (g.ignore != nullptr && g.ignore(id)) {","        continue;","      }","      const auto& e = g.edges[id];","      int to = e.from ^ e.to ^ i;","      if (dist[i] + e.cost < dist[to]) {","        dist[to] = dist[i] + e.cost;","        s.emplace(dist[to], to);","      }","    }","  }","  return dist;","  // returns numeric_limits<T>::max() if there's no path","}"],
        "description": "Dijkstra",
    }
    ,
    "Bridges": {
        "scope": "cpp",
        "prefix": "bridges",
        "body": ["template <typename T>","vector<bool> FindBridges(DfsUndigraph& g) {","  g.dfs_all();","  vector<bool> bridge(g.edges.size(), false);","  for (int i = 0; i < g.n; i++) {","    if (g.pv[i] != -1 && g.low[i] == g.pre[i]) {","      bridge[g.pe[i]] = true;","    }","  }","  return bridge;","}"],
        "description": "Bridges",
    }
    ,
    "Biconv": {
        "scope": "cpp",
        "prefix": "biconv",
        "body": ["template <typename T>","vector<int> FindBiconV(DfsUndigraph& g, int& cnt) {","  g.dfs_all();","  vector<int> node_comp(g.n);","  cnt = 0;","  for (int v : g.order) {","    if (g.pv[v] == -1) {","      node_comp[v] = -1;","      continue;","    }","    if (g.low[v] >= g.pre[g.pv[v]]) {","      node_comp[v] = cnt++;","    } else {","      node_comp[v] = node_comp[g.pv[v]];","    }","  }","  vector<int> edge_comp(g.edges.size());","  for (int id = 0; id < (int) g.edges.size(); id++) {","    if (g.ignore != nullptr && g.ignore(id)) {","      continue;","    }","    const auto& e = g.edges[id];","    int x = e.from;","    int y = e.to;","    int z = (g.depth[x] > g.depth[y] ? x : y);","    edge_comp[id] = node_comp[z];","  }","  return edge_comp;","}"],
        "description": "Biconv",
    }
    ,
    "Centroid Benq": {
        "scope": "cpp",
        "prefix": "centroidbenq",
        "body": ["/*","Description: The centroid of a tree of size $N$ is a vertex such that ","after removing it, all resulting subtrees have size at most $\\frac{N}{2}.$ ","Can support tree path queries and updates.","Time: O(N\\log N)","Source: own","Verification: ","https://codeforces.com/contest/342/problem/E","Triway Cup 2019 G","*/","","template <int SZ>","struct Centroid {","  vector<int> g[SZ];","  bool done[SZ];           // processed as centroid yet","  int sz[SZ];              // subtree size","  int pv[SZ];              // current pv","  pair<int, int> cen[SZ];  // {centroid above v, label of centroid subtree}","  vector<int> dist[SZ];    // dists to all centroid ancs","","  void add(int a, int b) {","    g[a].push_back(b);","    g[b].push_back(a);","  }","","  void dfs(int v) {","    sz[v] = 1;","    for (int u : g[v]) {","      if (!done[u] && u != pv[v]) {","        pv[u] = v;","        dfs(u);","        sz[v] += sz[u];","      }","    }","  }","","  int centroid(int v) {","    pv[v] = -1;","    dfs(v);","    while (true) {","      pair<int, int> mx = {0, 0};","      for (int u : g[v]) {","        if (!done[u] && u != pv[v]) {","          mx = max(mx, {sz[u], u});","        }","      }","      if (mx.first * 2 <= sz[v]) {","        return v;","      }","      v = mx.second;","    }","  }","","  void genDist(int v, int p) {","    dist[v].push_back(dist[p].back() + 1);","    for (int u : g[v]) {","      if (!done[u] && u != p) {","        genDist(u, v);","      }","    }","  }","","  void gen(pair<int, int> CEN, int v) {","    v = centroid(v);","    done[v] = 1;","    cen[v] = CEN;","    dist[v].push_back(0);","    int co = 0;","    trav(u, g[v]) if (!done[u]) genDist(u, v);","    trav(u, g[v]) if (!done[u]) gen({v, co++}, u);","  }","","  void init() {","    gen({-1, 0}, 1);","  }  // start with vertex 1","};"],
        "description": "Centroid Benq",
    }
    ,
    "Lca Forest": {
        "scope": "cpp",
        "prefix": "lcaforest",
        "body": ["template <typename T>","class LcaForest : public DfsForest<T> {","  // TODO: for LCA only, use HLD to save memory?"," public:","  using DfsForest<T>::edges;","  using DfsForest<T>::g;","  using DfsForest<T>::n;","  using DfsForest<T>::pv;","  using DfsForest<T>::pre;","  using DfsForest<T>::post;","  using DfsForest<T>::root;","  using DfsForest<T>::depth;","","  int h;","  vector<vector<int>> pr;","","  LcaForest(int _n) : DfsForest<T>(_n) {","  }","","  void build_lca() {","    assert(!pv.empty());","    int max_depth = 0;","    for (int i = 0; i < n; i++) {","      max_depth = max(max_depth, depth[i]);","    }","    h = 1;","    while ((1 << h) <= max_depth) {","      // don't use __lg in case n = 0 or 1?","      h++;","    }","    pr.resize(n);","    for (int i = 0; i < n; i++) {","      pr[i].resize(h);","      pr[i][0] = pv[i];","    }","    for (int j = 1; j < h; j++) {","      for (int i = 0; i < n; i++) {","        pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);","      }","    }","  }","","  bool anc(int x, int y) {","    return (pre[x] <= pre[y] && post[y] <= post[x]);","  }","","  int lca(int x, int y) {","    assert(!pr.empty());","    if (root[x] != root[y]) {","      return -1;","    }","    if (anc(x, y)) {","      return x;","    }","    if (anc(y, x)) {","      return y;","    }","    if (depth[x] > depth[y]) {","      swap(x, y);","    }","    // don't worry, depth[x] can't be 0 since anc(x, y) is false","    for (int j = __lg(depth[x]); j >= 0; j--) {","      if (pr[x][j] != -1 && !anc(pr[x][j], y)) {","        x = pr[x][j];","      }","    }","    return pr[x][0];","  }","};"],
        "description": "Lca Forest",
    }
    ,
    "Cutpoints": {
        "scope": "cpp",
        "prefix": "cutpoints",
        "body": ["template <typename T>","vector<bool> FindCutpoints(const DfsUndigraph<T>& g) {","  g.dfs_all();","  vector<bool> cutpoint(g.n, false);","  for (int i = 0; i < g.n; i++) {","    if (g.pv[i] != -1 && g.low[i] >= g.pre[g.pv[i]]) {","      cutpoint[g.pv[i]] = true;","    }","  }","  vector<int> children(g.n, 0);","  for (int i = 0; i < g.n; i++) {","    if (g.pv[i] != -1) {","      children[g.pv[i]]++;","    }","  }","  for (int i = 0; i < g.n; i++) {","    if (g.pv[i] == -1 && children[i] < 2) {","      cutpoint[i] = false;","    }","  }","  return cutpoint;","}"],
        "description": "Cutpoints",
    }
    ,
    "Centroid Namespace": {
        "scope": "cpp",
        "prefix": "centroidnamespace",
        "body": ["/*","\"Template\" centroid decomposition, although it's hard to be general here...","","The default aggregate calculated here is distance. Change the lines marked with","HERE to customize to your needs for the problem. :)","","Now it's named \"dist\". f does the same thing.","","Note that f[i][j] only makes sense for j <= depth[i].","","See here: https://dmoj.ca/submission/2081194","*/","","namespace centroid {","","const int N = 200005;","const int LOG = 21;","","int n;","vector<int> g[N];","","int pv[N];","vector<int> order;","int sz[N];","int depth[N];","","// data for the centroid tree","int cpv[N];","int cid[N];  // cid[v]: id of the subtree of v with respect to v's parent node","// for example, if node 1 has children 2, 3, 5, their labels are 0, 1, 2 in some order","int children[N];  // number of children in centroid tree","int cdepth[N];","int dist[N][LOG];  // dist[v][i]: distance to v's ancestor who has depth i","","int aux[N];   // aggregate value to calculate; HERE: possibly change to long long","int f[N][LOG];  // HERE: use same data type as above","","void dfs(int v, int p) {","  pv[v] = p;","  order.push_back(v);","  sz[v] = 1;","  for (int u : g[v]) {","    if (u == p || cdepth[u] != -1) {","      continue;","    }","    depth[u] = depth[v] + 1;","    // calculate what is needed","    ${1:aux[u] = aux[v] + 1;}","    dfs(u, v);","    sz[v] += sz[u];","  }","}","","void do_dfs_from(int v) {","  depth[v] = 0;","  aux[v] = ${2:0};","  order.clear();","  dfs(v, -1);","}","","int find_centroid(int v) {","  do_dfs_from(v);","  int h = sz[v] / 2;","  for (int u : order) {","    bool ok = (sz[v] - sz[u] <= h);","    for (int to : g[u]) {","      if (to == pv[u] || cdepth[to] != -1) {","        continue;","      }","      ok &= (sz[to] <= h);","    }","    if (ok) {","      return u;","    }","  }","  assert(0);","}","","void calculate(int v) {","  do_dfs_from(v);","  int d = cdepth[v];","  for (int i : order) {","    dist[i][d] = depth[i];","    f[i][d] = aux[i];","  }","}","","void dfs_cent(int v) {","  // v: the centroid of its current component","  // p: parent in centroid tree","  calculate(v);","  children[v] = 0;","  for (int u : g[v]) {","    if (cdepth[u] != -1) {","      continue;","    }","    int c = find_centroid(u);","    cdepth[c] = cdepth[v] + 1;","    cid[c] = children[v]++;","    cpv[c] = v;","    dfs_cent(c);","  }","}","","void build_centroid() {  // returns the root of the subtree","  fill(cdepth, cdepth + N, -1);","  order.reserve(N);","  int c = find_centroid(0);","  cdepth[c] = 0;","  cpv[c] = -1;","  dfs_cent(c);","}","","}  // namespace centroid","","using namespace centroid;"],
        "description": "Centroid Namespace",
    }
    ,
    "Hld": {
        "scope": "cpp",
        "prefix": "hld",
        "body": ["template <typename T>","class Graph {"," public:","  struct Edge {","    int from;","    int to;","    T cost;","  };","","  vector<Edge> edges;","  vector<vector<int>> g;","  int n;","","  function<bool(int)> ignore;","","  Graph(int _n) : n(_n) {","    g.resize(n);","    ignore = nullptr;","  }","","  virtual int add(int from, int to, T cost) = 0;","","  virtual void set_ignore_edge_rule(const function<bool(int)>& f) {","    ignore = f;","  }","","  virtual void reset_ignore_edge_rule() {","    ignore = nullptr;","  }","};","","template <typename T>","class Forest : public Graph<T> {"," public:","  using Graph<T>::edges;","  using Graph<T>::g;","  using Graph<T>::n;","","  Forest(int _n) : Graph<T>(_n) {","  }","","  int add(int from, int to, T cost = 1) {","    assert(0 <= from && from < n && 0 <= to && to < n);","    int id = (int) edges.size();","    assert(id < n - 1);","    g[from].push_back(id);","    g[to].push_back(id);","    edges.push_back({from, to, cost});","    return id;","  }","};","","template <typename T>","class DfsForest : public Forest<T> {"," public:","  using Forest<T>::edges;","  using Forest<T>::g;","  using Forest<T>::n;","  using Forest<T>::ignore;","","  vector<int> pv;","  vector<int> pe;","  vector<int> order;","  vector<int> pre;","  vector<int> post;","  vector<int> sz;","  vector<int> root;","  vector<int> depth;","  vector<T> dist;","","  DfsForest(int _n) : Forest<T>(_n) {","  }","","  void init() {","    pv = vector<int>(n, -1);","    pe = vector<int>(n, -1);","    order.clear();","    pre = vector<int>(n, -1);","    post = vector<int>(n, -1);","    sz = vector<int>(n, -1);","    root = vector<int>(n, -1);","    depth = vector<int>(n, -1);","    dist = vector<T>(n);","  }","","  void clear() {","    pv.clear();","    pe.clear();","    order.clear();","    pre.clear();","    post.clear();","    sz.clear();","    root.clear();","    depth.clear();","    dist.clear();","  }",""," private:","  void do_dfs(int v) {","    pre[v] = (int) order.size();","    order.push_back(v);","    sz[v] = 1;","    for (int id : g[v]) {","      if (id == pe[v] || (ignore != nullptr && ignore(id))) {","        continue;","      }","      const auto& e = edges[id];","      int to = e.from ^ e.to ^ v;","      depth[to] = depth[v] + 1;","      dist[to] = dist[v] + e.cost;","      pv[to] = v;","      pe[to] = id;","      root[to] = (root[v] != -1 ? root[v] : to);","      do_dfs(to);","      sz[v] += sz[to];","    }","    post[v] = (int) order.size() - 1;","  }","","  void do_dfs_from(int v) {","    depth[v] = 0;","    dist[v] = T{};","    root[v] = v;","    pv[v] = pe[v] = -1;","    do_dfs(v);","  }",""," public:","  void dfs(int v, bool clear_order = true) {","    if (pv.empty()) {","      init();","    } else {","      if (clear_order) {","        order.clear();","      }","    }","    do_dfs_from(v);","  }","","  void dfs_all() {","    init();","    for (int v = 0; v < n; v++) {","      if (depth[v] == -1) {","        do_dfs_from(v);","      }","    }","    assert((int) order.size() == n);","  }","};","","template <typename T>","class LcaForest : public DfsForest<T> {","  // TODO: for LCA only, use HLD to save memory?"," public:","  using DfsForest<T>::edges;","  using DfsForest<T>::g;","  using DfsForest<T>::n;","  using DfsForest<T>::pv;","  using DfsForest<T>::pre;","  using DfsForest<T>::post;","  using DfsForest<T>::root;","  using DfsForest<T>::depth;","","  int h;","  vector<vector<int>> pr;","","  LcaForest(int _n) : DfsForest<T>(_n) {","  }","","  void build_lca() {","    assert(!pv.empty());","    int max_depth = 0;","    for (int i = 0; i < n; i++) {","      max_depth = max(max_depth, depth[i]);","    }","    h = 1;","    while ((1 << h) <= max_depth) {","      // don't use __lg in case n = 0 or 1?","      h++;","    }","    pr.resize(n);","    for (int i = 0; i < n; i++) {","      pr[i].resize(h);","      pr[i][0] = pv[i];","    }","    for (int j = 1; j < h; j++) {","      for (int i = 0; i < n; i++) {","        pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);","      }","    }","  }","","  bool anc(int x, int y) {","    return (pre[x] <= pre[y] && post[y] <= post[x]);","  }","","  int lca(int x, int y) {","    assert(!pr.empty());","    if (root[x] != root[y]) {","      return -1;","    }","    if (anc(x, y)) {","      return x;","    }","    if (anc(y, x)) {","      return y;","    }","    if (depth[x] > depth[y]) {","      swap(x, y);","    }","    // don't worry, depth[x] can't be 0 since anc(x, y) is false","    for (int j = __lg(depth[x]); j >= 0; j--) {","      if (pr[x][j] != -1 && !anc(pr[x][j], y)) {","        x = pr[x][j];","      }","    }","    return pr[x][0];","  }","};","","template <typename T>","class HldForest : public LcaForest<T> {"," public:","  using LcaForest<T>::edges;","  using LcaForest<T>::g;","  using LcaForest<T>::n;","  using LcaForest<T>::ignore;","  using LcaForest<T>::pv;","  using LcaForest<T>::sz;","  using LcaForest<T>::pre;","  using LcaForest<T>::order;","  using LcaForest<T>::depth;","  using LcaForest<T>::dfs;","  using LcaForest<T>::dfs_all;","  using LcaForest<T>::lca;","  using LcaForest<T>::build_lca;","","  vector<int> head;","  vector<int> visited;","","  HldForest(int _n) : LcaForest<T>(_n) {","    visited.resize(n);","  }","","  void build_hld(const vector<int>& vs) {","    for (int tries = 0; tries < 2; tries++) {","      if (vs.empty()) {","        dfs_all();","      } else {","        order.clear();","        for (int v : vs) {","          dfs(v, false);","        }","        assert((int) order.size() == n);","      }","      if (tries == 1) {","        break;","      }","      for (int i = 0; i < n; i++) {","        if (g[i].empty()) {","          continue;","        }","        int best = -1, bid = 0;","        for (int j = 0; j < (int) g[i].size(); j++) {","          int id = g[i][j];","          if (ignore != nullptr && ignore(id)) {","            continue;","          }","          int v = edges[id].from ^ edges[id].to ^ i;","          if (pv[v] != i) {","            continue;","          }","          if (sz[v] > best) {","            best = sz[v];","            bid = j;","          }","        }","        swap(g[i][0], g[i][bid]);","      }","    }","    build_lca();","    head.resize(n);","    for (int i = 0; i < n; i++) {","      head[i] = i;","    }","    for (int i = 0; i < n - 1; i++) {","      int x = order[i];","      int y = order[i + 1];","      if (pv[y] == x) {","        head[y] = head[x];","      }","    }","  }","","  void build_hld(int v) {","    build_hld(vector<int>(1, v));","  }","","  void build_hld_all() {","    build_hld(vector<int>());","  }","","  vector<pair<int, int>> get_path(int x, int y) {","    vector<pair<int, int>> path[2];","    int z = lca(x, y);","    for (int id = 0; id < 2; id++) {","      int v = (id == 0 ? x : y);","      while (v != z) {","        if (depth[head[v]] <= depth[z]) {","          path[id].emplace_back(pre[z] + 1, pre[v]);","          break;","        }","        path[id].emplace_back(pre[head[v]], pre[v]);","        v = pv[head[v]];","      }","    }","    vector<pair<int, int>> ret;","    for (int i = 0; i < (int) path[0].size(); i++) {","      ret.emplace_back(path[0][i].second, path[0][i].first);","    }","    ret.emplace_back(-1, pre[z]);","    for (int i = (int) path[1].size() - 1; i >= 0; i--) {","      ret.push_back(path[1][i]);","    }","    return ret;","    // returns segments of the path:","    //   first from x to lca, reversed segments","    //   then (-1, pre[lca])","    //   then from lca to y, direct segments","    // but in most cases, apply_on_path should be enough","  }","","  bool apply_on_path(int x, int y, bool with_lca, function<void(int, int, bool)> f) {","    // f(x, y, up): up -- whether this part of the path goes up","    assert(!head.empty());","    int z = lca(x, y);","    if (z == -1) {","      return false;","    }","    {","      int v = x;","      while (v != z) {","        if (depth[head[v]] <= depth[z]) {","          f(pre[z] + 1, pre[v], true);","          break;","        }","        f(pre[head[v]], pre[v], true);","        v = pv[head[v]];","      }","    }","    if (with_lca) {","      f(pre[z], pre[z], false);","    }","    {","      int v = y;","      int cnt_visited = 0;","      while (v != z) {","        if (depth[head[v]] <= depth[z]) {","          f(pre[z] + 1, pre[v], false);","          break;","        }","        visited[cnt_visited++] = v;","        v = pv[head[v]];","      }","      for (int at = cnt_visited - 1; at >= 0; at--) {","        v = visited[at];","        f(pre[head[v]], pre[v], false);","      }","    }","    return true;","  }","};"],
        "description": "Hld",
    }
    ,
    "Undigraph": {
        "scope": "cpp",
        "prefix": "undigraph",
        "body": ["template <typename T>","class Undigraph : public Graph<T> {"," public:","  using Graph<T>::edges;","  using Graph<T>::g;","  using Graph<T>::n;","","  Undigraph(int _n) : Graph<T>(_n) {","  }","","  int add(int from, int to, T cost = 1) {","    assert(0 <= from && from < n && 0 <= to && to < n);","    int id = (int) edges.size();","    g[from].push_back(id);","    g[to].push_back(id);","    edges.push_back({from, to, cost});","    return id;","  }","};"],
        "description": "Undigraph",
    }
    ,
    "Vtree Arrays": {
        "scope": "cpp",
        "prefix": "vtreearrays",
        "body": ["namespace virtual_tree {","","const int N = ${1:500005};","const int H = ${2:20};","","int n;","vector<int> g[N];","int from[N], to[N];","long long cost[N];","","int pv[N];","int pre[N], post[N];","vector<int> order;","long long dist[N];","","int pr[N][H];","","void dfs(int v, int p) {","  pv[v] = p;","  pre[v] = (int) order.size();","  order.push_back(v);","  for (int id : g[v]) {","    int u = from[id] ^ to[id] ^ v;","    if (u == p) {","      continue;","    }","    dist[u] = dist[v] + cost[id];","    dfs(u, v);","  }","  post[v] = (int) order.size() - 1;","}","","void do_dfs_from(int v) {","  order.clear();","  dfs(v, -1);","}","","bool anc(int x, int y) {","  return (pre[x] <= pre[y] && post[y] <= post[x]);","}","","int lca(int x, int y) {","  if (anc(x, y)) {","    return x;","  }","  if (anc(y, x)) {","    return y;","  }","  for (int j = H - 1; j >= 0; j--) {","    if (pr[x][j] != -1 && !anc(pr[x][j], y)) {","      x = pr[x][j];","    }","  }","  return pv[x];","}","","vector<int> vt[N];","int vfrom[N], vto[N];","long long vcost[N];","","int vpv[N];","","void init() {","  do_dfs_from(0);","  for (int i = 0; i < n; i++) {","    pr[i][0] = pv[i];","  }","  for (int j = 1; j < H; j++) {","    for (int i = 0; i < n; i++) {","      pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);","    }","  }","}","","/**"," * Builds the virtual tree with the given nodes."," * @param v the nodes to include in the virtual tree"," */","void build_vtree(vector<int>& v) {","  sort(v.begin(), v.end(), [&](int x, int y) {","    return pre[x] < pre[y];","  });","  int cnt = (int) v.size();","  for (int i = 0; i < cnt - 1; i++) {","    v.push_back(lca(v[i], v[i + 1]));","  }","  sort(v.begin(), v.end(), [&](int x, int y) {","    return pre[x] < pre[y];","  });","  for (int x : v) {","    vt[x].clear();","  }","  vector<int> stk(1, v[0]);  // highest node is always in the virtual tree","  int ecnt = 0;  // edges added so far","  for (int z = 1; z < (int) v.size(); z++) {","    int u = v[z];","    while (!anc(stk.back(), u)) {","      stk.pop_back();","    }","    int id = ecnt++;","    int p = stk.back();","    vt[u].push_back(id);","    vt[p].push_back(id);","    vfrom[id] = u;","    vto[id] = p;","    vcost[id] = dist[u] - dist[p];","    vpv[u] = p;","    stk.push_back(u);","  }","}","","}  // namespace virtual_tree","","using namespace virtual_tree;"],
        "description": "Vtree Arrays",
    }
    ,
    "Twosat": {
        "scope": "cpp",
        "prefix": "twosat",
        "body": ["class TwoSat {"," public:","  int n;","  Digraph<int> g;","","  TwoSat(int _n) : n(_n), g(Digraph<int>(2 * n)) {","  }","","  void add(int x, int value_x) {","    // (v[x] == value_x)","    assert(0 <= x && x < n);","    assert(value_x == 0 || value_x == 1);","    g.add(2 * x + (value_x ^ 1), 2 * x + value_x);","  }","","  void add(int x, int value_x, int y, int value_y) {","    // (v[x] == value_x || v[y] == value_y)","    assert(0 <= x && x < n && 0 <= y && y < n);","    assert(value_x == 0 || value_x == 1);","    assert(value_y == 0 || value_y == 1);","    g.add(2 * x + (value_x ^ 1), 2 * y + value_y);","    g.add(2 * y + (value_y ^ 1), 2 * x + value_x);","  }","","  void add_xor(int x, int y) {","    // (v[x] ^ v[y])","    assert(0 <= x && x < n && 0 <= y && y < n);","    g.add(2 * x, 2 * y + 1);","    g.add(2 * y + 1, 2 * x);","    g.add(2 * y, 2 * x + 1);","    g.add(2 * x + 1, 2 * y);","  }","","  vector<int> solve() {","    int cnt;","    vector<int> comp = find_scc(g, cnt);","    vector<int> res(n);","    for (int i = 0; i < n; i++) {","      if (comp[2 * i] == comp[2 * i + 1]) {","        return vector<int>();","      }","      // comp[2 * i] > comp[2 * i + 1] means 2 * i can reach 2 * i + 1","      // (the SCC implementation yields components in reverse topsort order)","      res[i] = (comp[2 * i] > comp[2 * i + 1]);","    }","    return res;","  }","};"],
        "description": "Twosat",
    }
    ,
    "Dfs Undigraph": {
        "scope": "cpp",
        "prefix": "dfsundigraph",
        "body": ["template <typename T>","class DfsUndigraph : public Undigraph<T> {","  using Undigraph<T>::edges;","  using Undigraph<T>::g;","  using Undigraph<T>::n;","  using Undigraph<T>::ignore;","","  vector<int> pv;","  vector<int> pe;","  vector<int> order;","  vector<int> pre;","  vector<int> post;","  vector<int> sz;","  vector<int> root;","  vector<int> depth;","  vector<int> low;","  vector<T> dist;","  vector<int> was;","  int attempt;","","  DfsUndigraph(int _n) : Undigraph<T>(_n) {","  }","","  void init() {","    pv = vector<int>(n, -1);","    pe = vector<int>(n, -1);","    order.clear();","    pre = vector<int>(n, -1);","    post = vector<int>(n, -1);","    sz = vector<int>(n, 0);","    root = vector<int>(n, -1);","    depth = vector<int>(n, -1);","    low = vector<int>(n, -1);","    dist = vector<T>(n);","    was = vector<int>(n, -1);","    attempt = 0;","  }","","  void clear() {","    pv.clear();","    pe.clear();","    order.clear();","    pre.clear();","    post.clear();","    sz.clear();","    root.clear();","    depth.clear();","    low.clear();","    dist.clear();","    was.clear();","  }",""," private:","  void do_dfs(int v) {","    was[v] = attempt;","    pre[v] = (int) order.size();","    order.push_back(v);","    sz[v] = 1;","    low[v] = pre[v];","    for (int id : g[v]) {","      if (id == pe[v] || (ignore != nullptr && ignore(id))) {","        continue;","      }","      const auto& e = edges[id];","      int to = e.from ^ e.to ^ v;","      if (was[to] == attempt) {","        low[v] = min(low[v], pre[to]);","        continue;","      }","      pv[to] = v;","      pe[to] = id;","      root[to] = root[v];","      depth[to] = depth[v] + 1;","      dist[to] = dist[v] + e.cost;","      do_dfs(to);","      sz[v] += sz[to];","      low[v] = min(low[v], low[to]);","    }","    post[v] = (int) order.size() - 1;","  }","","  void do_dfs_from(int v) {","    pv[v] = -1;","    pe[v] = -1;","    root[v] = v;","    depth[v] = 0;","    dist[v] = T{};","    attempt++;","    do_dfs(v);","  }",""," public:","  void dfs(int v, bool clear_order = true) {","    if (pv.empty()) {","      init();","    } else {","      if (clear_order) {","        order.clear();","      }","    }","    do_dfs_from(v);","  }","","  void dfs_all() {","    init();","    for (int v = 0; v < n; v++) {","      if (root[v] == -1) {","        do_dfs_from(v);","      }","    }","    assert((int) order.size() == n);","  }","};"],
        "description": "Dfs Undigraph",
    }
    ,
    "Mst": {
        "scope": "cpp",
        "prefix": "mst",
        "body": ["template <typename T>","vector<int> FindMst(const Undigraph<T>& g, T& ans) {","  vector<int> order(g.edges.size());","  iota(order.begin(), order.end(), 0);","  sort(order.begin(), order.end(), [&g](int a, int b) {","    return g.edges[a].cost < g.edges[b].cost;","  });","  Dsu d(g.n);","  vector<int> ans_list;","  ans = 0;","  for (int id : order) {","    if (g.ignore != nullptr && g.ignore(id)) {","      continue;","    }","    const auto& e = g.edges[id];","    if (d.unite(e.from, e.to)) {","      ans_list.push_back(id);","      ans += e.cost;","    }","  }","  return ans_list;","  // returns edge ids of minimum \"spanning\" forest","}"],
        "description": "Mst",
    }
    ,
    "Forest": {
        "scope": "cpp",
        "prefix": "forest",
        "body": ["template <typename T>","class Forest : public Graph<T> {"," public:","  using Graph<T>::edges;","  using Graph<T>::g;","  using Graph<T>::n;","","  Forest(int _n) : Graph<T>(_n) {","  }","","  int add(int from, int to, T cost = 1) {","    assert(0 <= from && from < n && 0 <= to && to < n);","    int id = (int) edges.size();","    assert(id < n - 1);","    g[from].push_back(id);","    g[to].push_back(id);","    edges.push_back({from, to, cost});","    return id;","  }","};"],
        "description": "Forest",
    }
    ,
    "Topsort": {
        "scope": "cpp",
        "prefix": "topsort",
        "body": ["template <typename T>","vector<int> FindTopsort(const Digraph<T>& g) {","  vector<int> indeg(g.n, 0);","  for (int id = 0; id < (int) g.edges.size(); id++) {","    if (g.ignore != nullptr && g.ignore(id)) {","      continue;","    }","    ++indeg[g.edges[id].to];","  }","  vector<int> x;","  for (int i = 0; i < g.n; i++) {","    if (indeg[i] == 0) {","      x.push_back(i);","    }","  }","  for (int ptr = 0; ptr < (int) x.size(); ptr++) {","    int i = x[ptr];","    for (int id : g.g[i]) {","      if (g.ignore != nullptr && g.ignore(id)) {","        continue;","      }","      auto& e = g.edges[id];","      int to = e.to;","      if (--indeg[to] == 0) {","        x.push_back(to);","      }","    }","  }","  if ((int) x.size() != g.n) {","    return vector<int>();","  }","  return x;","  // returns an empty vector if the digraph is not a DAG","}"],
        "description": "Topsort",
    }
    ,
    "Graph": {
        "scope": "cpp",
        "prefix": "graph",
        "body": ["template <typename T>","class Graph {"," public:","  struct Edge {","    int from;","    int to;","    T cost;","  };","","  vector<Edge> edges;","  vector<vector<int>> g;","  int n;","","  function<bool(int)> ignore;","","  Graph(int _n) : n(_n) {","    g.resize(n);","    ignore = nullptr;","  }","","  virtual int add(int from, int to, T cost) = 0;","","  virtual void set_ignore_edge_rule(const function<bool(int)>& f) {","    ignore = f;","  }","","  virtual void reset_ignore_edge_rule() {","    ignore = nullptr;","  }","};"],
        "description": "Graph",
    }
    ,
    "Bicone": {
        "scope": "cpp",
        "prefix": "bicone",
        "body": ["template <typename T>","vector<int> FindBicone(DfsUndigraph<T>& g, int& cnt) {","  g.dfs_all();","  vector<int> node_comp(g.n);","  cnt = 0;","  for (int v : g.order) {","    if (g.pv[v] == -1 || g.low[v] == g.pre[v]) {","      node_comp[v] = cnt++;","    } else {","      node_comp[v] = node_comp[g.pv[v]];","    }","  }","  return node_comp;","}","","template <typename T>","Forest<T> GetForest(const DfsUndigraph<T>& g, const vector<int>& node_comp) {","  int cnt = *max_element(node_comp.begin(), node_comp.end());","  Forest<T> f(cnt);","  for (int id = 0; id < (int) g.edges.size(); id++) {","    if (g.ignore != nullptr && g.ignore(id)) {","      continue;","    }","    const auto& e = edges[id];","    if (node_comp[e.from] != node_comp[e.to]) {","      f.add(e.from, e.to);","    }","  }","  return f;","  // returns the tree corresponding to the original graph with","  // 2-edge-connected components contracted to a single node","}"],
        "description": "Bicone",
    }
    ,
    "Dfs Forest": {
        "scope": "cpp",
        "prefix": "dfsforest",
        "body": ["template <typename T>","class DfsForest : public Forest<T> {"," public:","  using Forest<T>::edges;","  using Forest<T>::g;","  using Forest<T>::n;","  using Forest<T>::ignore;","","  vector<int> pv;","  vector<int> pe;","  vector<int> order;","  vector<int> pre;","  vector<int> post;","  vector<int> sz;","  vector<int> root;","  vector<int> depth;","  vector<T> dist;","","  DfsForest(int _n) : Forest<T>(_n) {","  }","","  void init() {","    pv = vector<int>(n, -1);","    pe = vector<int>(n, -1);","    order.clear();","    pre = vector<int>(n, -1);","    post = vector<int>(n, -1);","    sz = vector<int>(n, -1);","    root = vector<int>(n, -1);","    depth = vector<int>(n, -1);","    dist = vector<T>(n);","  }","","  void clear() {","    pv.clear();","    pe.clear();","    order.clear();","    pre.clear();","    post.clear();","    sz.clear();","    root.clear();","    depth.clear();","    dist.clear();","  }",""," private:","  void do_dfs(int v) {","    pre[v] = (int) order.size();","    order.push_back(v);","    sz[v] = 1;","    for (int id : g[v]) {","      if (id == pe[v] || (ignore != nullptr && ignore(id))) {","        continue;","      }","      const auto& e = edges[id];","      int to = e.from ^ e.to ^ v;","      depth[to] = depth[v] + 1;","      dist[to] = dist[v] + e.cost;","      pv[to] = v;","      pe[to] = id;","      root[to] = (root[v] != -1 ? root[v] : to);","      do_dfs(to);","      sz[v] += sz[to];","    }","    post[v] = (int) order.size() - 1;","  }","","  void do_dfs_from(int v) {","    depth[v] = 0;","    dist[v] = T{};","    root[v] = v;","    pv[v] = pe[v] = -1;","    do_dfs(v);","  }",""," public:","  void dfs(int v, bool clear_order = true) {","    if (pv.empty()) {","      init();","    } else {","      if (clear_order) {","        order.clear();","      }","    }","    do_dfs_from(v);","  }","","  void dfs_all() {","    init();","    for (int v = 0; v < n; v++) {","      if (depth[v] == -1) {","        do_dfs_from(v);","      }","    }","    assert((int) order.size() == n);","  }","};"],
        "description": "Dfs Forest",
    }
    ,
    "Succ": {
        "scope": "cpp",
        "prefix": "succ",
        "body": ["vector<vector<int>> FindCycles(int n, const vector<int>& succ) {","  vector<int> pos(n, -1);","  vector<int> started(n, -1);","  vector<vector<int>> cycles;","  for (int i = 0; i < n; i++) {","    if (started[i] != -1) {","      continue;","    }","    int v = i;","    vector<int> seq;","    while (true) {","      if (started[v] != -1) {","        if (started[v] == i) {","          vector<int> cycle(seq.begin() + pos[v], seq.end());","          cycles.push_back(cycle);","        }","        break;","      }","      started[v] = i;","      pos[v] = (int) seq.size();","      seq.push_back(v);","      v = succ[v];","    }","  }","  return cycles;","}"],
        "description": "Succ",
    }
    ,
    "Hld Forest": {
        "scope": "cpp",
        "prefix": "hldforest",
        "body": ["template <typename T>","class HldForest : public LcaForest<T> {"," public:","  using LcaForest<T>::edges;","  using LcaForest<T>::g;","  using LcaForest<T>::n;","  using LcaForest<T>::ignore;","  using LcaForest<T>::pv;","  using LcaForest<T>::sz;","  using LcaForest<T>::pre;","  using LcaForest<T>::order;","  using LcaForest<T>::depth;","  using LcaForest<T>::dfs;","  using LcaForest<T>::dfs_all;","  using LcaForest<T>::lca;","  using LcaForest<T>::build_lca;","","  vector<int> head;","  vector<int> visited;","","  HldForest(int _n) : LcaForest<T>(_n) {","    visited.resize(n);","  }","","  void build_hld(const vector<int>& vs) {","    for (int tries = 0; tries < 2; tries++) {","      if (vs.empty()) {","        dfs_all();","      } else {","        order.clear();","        for (int v : vs) {","          dfs(v, false);","        }","        assert((int) order.size() == n);","      }","      if (tries == 1) {","        break;","      }","      for (int i = 0; i < n; i++) {","        if (g[i].empty()) {","          continue;","        }","        int best = -1, bid = 0;","        for (int j = 0; j < (int) g[i].size(); j++) {","          int id = g[i][j];","          if (ignore != nullptr && ignore(id)) {","            continue;","          }","          int v = edges[id].from ^ edges[id].to ^ i;","          if (pv[v] != i) {","            continue;","          }","          if (sz[v] > best) {","            best = sz[v];","            bid = j;","          }","        }","        swap(g[i][0], g[i][bid]);","      }","    }","    build_lca();","    head.resize(n);","    for (int i = 0; i < n; i++) {","      head[i] = i;","    }","    for (int i = 0; i < n - 1; i++) {","      int x = order[i];","      int y = order[i + 1];","      if (pv[y] == x) {","        head[y] = head[x];","      }","    }","  }","","  void build_hld(int v) {","    build_hld(vector<int>(1, v));","  }","","  void build_hld_all() {","    build_hld(vector<int>());","  }","","  vector<pair<int, int>> get_path(int x, int y) {","    vector<pair<int, int>> path[2];","    int z = lca(x, y);","    for (int id = 0; id < 2; id++) {","      int v = (id == 0 ? x : y);","      while (v != z) {","        if (depth[head[v]] <= depth[z]) {","          path[id].emplace_back(pre[z] + 1, pre[v]);","          break;","        }","        path[id].emplace_back(pre[head[v]], pre[v]);","        v = pv[head[v]];","      }","    }","    vector<pair<int, int>> ret;","    for (int i = 0; i < (int) path[0].size(); i++) {","      ret.emplace_back(path[0][i].second, path[0][i].first);","    }","    ret.emplace_back(-1, pre[z]);","    for (int i = (int) path[1].size() - 1; i >= 0; i--) {","      ret.push_back(path[1][i]);","    }","    return ret;","    // returns segments of the path:","    //   first from x to lca, reversed segments","    //   then (-1, pre[lca])","    //   then from lca to y, direct segments","    // but in most cases, apply_on_path should be enough","  }","","  bool apply_on_path(int x, int y, bool with_lca, function<void(int, int, bool)> f) {","    // f(x, y, up): up -- whether this part of the path goes up","    assert(!head.empty());","    int z = lca(x, y);","    if (z == -1) {","      return false;","    }","    {","      int v = x;","      while (v != z) {","        if (depth[head[v]] <= depth[z]) {","          f(pre[z] + 1, pre[v], true);","          break;","        }","        f(pre[head[v]], pre[v], true);","        v = pv[head[v]];","      }","    }","    if (with_lca) {","      f(pre[z], pre[z], false);","    }","    {","      int v = y;","      int cnt_visited = 0;","      while (v != z) {","        if (depth[head[v]] <= depth[z]) {","          f(pre[z] + 1, pre[v], false);","          break;","        }","        visited[cnt_visited++] = v;","        v = pv[head[v]];","      }","      for (int at = cnt_visited - 1; at >= 0; at--) {","        v = visited[at];","        f(pre[head[v]], pre[v], false);","      }","    }","    return true;","  }","};"],
        "description": "Hld Forest",
    }
    ,
    "Offline Dynamic Mst": {
        "scope": "cpp",
        "prefix": "offlinedynamicmst",
        "body": ["struct Dsu {","  int n;","  vector<int> p;","  vector<int> h;","  vector<pair<int, int>> ops;","  stack<int> saves;","  int comps;","","  Dsu() {","    n = -1;","  }","","  Dsu(int _n) : n(_n) {","    p.resize(n);","    iota(p.begin(), p.end(), 0);","    h.resize(n, 0);","    comps = n;","  }","","  int get(int x) {","    while (x != p[x]) {","      x = p[x];","    }","    return x;","  }","","  bool unite(int x, int y) {","    if (comps == 1) {","      return false;","    }","    x = get(x);","    y = get(y);","    if (x == y) {","      return false;","    }","    if (h[x] > h[y]) {","      swap(x, y);","    }","    p[x] = y;","    ops.emplace_back(x, h[y]);","    if (h[x] == h[y]) {","      h[y]++;","    }","    comps -= 1;","    return true;","  }","","  void undo() {","    assert(!ops.empty());","    int x, height;","    tie(x, height) = ops.back();","    ops.pop_back();","    int y = p[x];","    h[y] = height;","    p[x] = x;","    comps += 1;","  }","","  void save() {","    saves.push(ops.size());","  }","","  void revert() {","    assert(!saves.empty());","    while ((int) ops.size() > saves.top()) {","      undo();","    }","    saves.pop();","  }","};","","class OfflineDynamicMst {","  int n;","  int m;","  int q;","  vector<int> from;","  vector<int> to;","  vector<int> cost;","  vector<int> echange;","  vector<int> ecost;","  Dsu d;","","  vector<bool> changes;","  vector<long long> ans;","","  void solve(int l, int r, vector<int>& maybe, long long cur) {","    if (l == r) {","      cost[echange[l]] = ecost[l];","      sort(maybe.begin(), maybe.end(), [&](int i, int j) { return cost[i] < cost[j]; });","      d.save();","      for (int id : maybe) {","        if (d.unite(from[id], to[id])) {","          cur += cost[id];","        }","      }","      ans[l] = cur;","      d.revert();","      return;","    }","    d.save();","    for (int qid = l; qid <= r; qid++) {","      int id = echange[qid];","      changes[id] = true;","      d.unite(from[id], to[id]);","    }","    vector<int> must;","    sort(maybe.begin(), maybe.end(), [&](int i, int j) { return cost[i] < cost[j]; });","    for (int id : maybe) {","      if (!changes[id] && d.unite(from[id], to[id])) {","        must.push_back(id);","      }","    }","    d.revert();","    d.save();","    for (int id : must) {","      d.unite(from[id], to[id]);","      cur += cost[id];","    }","    vector<int> new_maybe;","    d.save();","    for (int id : maybe) {","      if (changes[id] || d.unite(from[id], to[id])) {","        new_maybe.push_back(id);","      }","    }","    d.revert();","    for (int qid = l; qid <= r; qid++) {","      int id = echange[qid];","      changes[id] = false;","    }","    int y = (l + r) >> 1;","    solve(l, y, new_maybe, cur);","    solve(y + 1, r, new_maybe, cur);","    d.revert();","  }",""," public:","  OfflineDynamicMst(int _n) : n(_n) {","    d = Dsu(n);","    m = 0;","    q = 0;","    echange.push_back(0);","    ecost.push_back(0);","  }","","  void add_edge(int u, int v, int w) {","    assert(0 <= u && u < n && 0 <= v && v < n);","    from.push_back(u);","    to.push_back(v);","    cost.push_back(w);","    m += 1;","  }","","  void add_change(int id, int w) {","    echange.push_back(id);","    ecost.push_back(w);","    q += 1;","  }","","  vector<long long> solve() {","    assert(n - 1 <= m);","    // initial MST query","    echange[0] = 0;","    ecost[0] = cost[0];","    q += 1;","    changes.resize(m, false);","    vector<int> ids(m);","    iota(ids.begin(), ids.end(), 0);","    ans.resize(q);","    solve(0, q - 1, ids, 0);","    return ans;","  }","};"],
        "description": "Offline Dynamic Mst",
    }
    ,
    "Scc": {
        "scope": "cpp",
        "prefix": "scc",
        "body": ["template <typename T>","vector<int> FindScc(const Digraph<T>& g, int& cnt) {","  vector<int> pre(g.n, -1);","  vector<int> low(g.n, -1);","  stack<int> stk;","  vector<bool> on_stk(g.n, false);","  vector<int> comp(g.n);","  int when = 0;","  cnt = 0;","  function<void(int)> Dfs = [&](int v) {","    pre[v] = low[v] = when++;","    stk.push(v);","    on_stk[v] = true;","    for (int id : g.g[v]) {","      const auto& e = g.edges[id];","      int to = e.to;","      if (pre[to] != -1) {","        if (on_stk[to]) {","          low[v] = min(low[v], pre[to]);","        }","        continue;","      }","      Dfs(to);","      low[v] = min(low[v], low[to]);","    }","    if (low[v] == pre[v]) {","      int u;","      do {","        u = stk.top();","        stk.pop();","        on_stk[u] = false;","        comp[u] = cnt;","      } while (u != v);","      cnt++;","    }","  };","  for (int i = 0; i < g.n; i++) {","    if (pre[i] == -1) {","      Dfs(i);","    }","  }","  return comp;","  // comp[i] >= comp[j] for all edges i -> j,","  // thus a topological sort of the DAG is the component ids in decreasing","  // order, i.e. cnt - 1, cnt - 2, ..., 1, 0","}","","/**"," * Returns the metagraph for the directed graph after clustering."," * @param g the graph to contract"," * @param comp the vector giving the SCC id of each node"," * @return the metagraph, which is always a DAG"," */","template <typename T>","Digraph<T> GetDag(const Digraph<T>& g, const vector<int>& comp) {","  int cnt = *max_element(comp.begin(), comp.end()) + 1;","  Digraph<T> dag(cnt);","  set<pair<int, int>> edge_set;","  for (const auto& e : g.edges) {","    int u = comp[e.from];","    int v = comp[e.to];","    if (u == v) {","      continue;","    }","    if (!edge_set.count({u, v})) {","      dag.add(u, v);","      edge_set.emplace(u, v);","    }","  }","  return dag;","}"],
        "description": "Scc",
    }
    ,
    "Digraph": {
        "scope": "cpp",
        "prefix": "digraph",
        "body": ["template <typename T>","class Digraph : public Graph<T> {"," public:","  using Graph<T>::edges;","  using Graph<T>::g;","  using Graph<T>::n;","  using Graph<T>::ignore;","","  Digraph(int _n) : Graph<T>(_n) {","  }","","  int add(int from, int to, T cost = 1) {","    assert(0 <= from && from < n && 0 <= to && to < n);","    int id = (int) edges.size();","    g[from].push_back(id);","    edges.push_back({from, to, cost});","    return id;","  }","","  Digraph<T> reverse() const {","    Digraph<T> rev;","    for (const auto& e : edges) {","      rev.add(e.to, e.from, e.cost);","    }","    if (ignore != nullptr) {","      rev.set_ignore_edge_rule([&](int id) {","        return ignore(id);","      });","    }","    return rev;","  }","};"],
        "description": "Digraph",
    }
    ,
    "Centroid": {
        "scope": "cpp",
        "prefix": "centroid",
        "body": ["/*","Description:","a class that represents a graph and its centroid tree.","","TODO: add ids for children for each node as in centroid_namespace.cpp","*/","","class Centroid {"," public:","  struct Edge {","    int from;","    int to;","    int cost;","  };","","  int n;","  vector<vector<int>> g;","  vector<Edge> edges;","","  vector<int> pv;","  vector<int> order;","  vector<int> sz;","  vector<int> depth;","","  // data for the centroid tree","  int h;","  vector<int> cpv;","  vector<int> cdepth;","  vector<vector<int>> dist;  // dist[v][i]: distance to v's ancestor who has depth i","  vector<int> subtree;       // subtree[v] stores information for subtree of node v","  // currently stores the subtree sizes; no use cases yet in problems","","  vector<int> aux;        // aggregate value to calculate","  vector<vector<int>> f;  // f[v][i]: the aggregate of v to the parent in centroid tree with depth i","","  Centroid(int _n) : n(_n) {","    g.resize(n);","    pv.resize(n);","    order.reserve(n);  // reserve for slightly faster first DFS?","    sz.resize(n);","    depth.resize(n);","","    h = 32 - __builtin_clz(n);","    cpv.resize(n);","    cdepth.resize(n, -1);","    dist.resize(n, vector<int>(h));","    subtree.resize(n);","","    aux.resize(n);","    f.resize(n, vector<int>(h));","  }","","  int add(int from, int to, int cost = 1) {","    assert(0 <= from && from < n && 0 <= to && to < n && from != to);","    int id = (int) edges.size();","    assert(id < n - 1);","    g[from].push_back(id);","    g[to].push_back(id);","    edges.push_back({from, to, cost});","    if (id == n - 2) {","      build_centroid();","    }","    return id;","  }",""," private:","  void dfs(int v, int p) {","    pv[v] = p;","    order.push_back(v);","    sz[v] = 1;","    for (int id : g[v]) {","      const auto& e = edges[id];","      int u = e.from ^ e.to ^ v;","      if (u == p || cdepth[u] != -1) {","        continue;","      }","      depth[u] = depth[v] + 1;","      aux[u] = aux[v] + 1;  // HERE: change to calculate what is needed","      dfs(u, v);","      sz[v] += sz[u];","    }","  }","","  void do_dfs_from(int v) {","    depth[v] = 0;","    aux[v] = 0;  // HERE: customize","    order.clear();","    dfs(v, -1);","  }","","  int find_centroid(int v) {","    do_dfs_from(v);","    int h = sz[v] / 2;","    for (int u : order) {","      bool ok = (sz[v] - sz[u] <= h);","      for (int id : g[u]) {","        const auto& e = edges[id];","        int to = e.from ^ e.to ^ u;","        if (to == pv[u] || cdepth[to] != -1) {","          continue;","        }","        ok &= (sz[to] <= h);","      }","      if (ok) {","        return u;","      }","    }","    assert(0);","  }","","  void calculate(int v) {","    do_dfs_from(v);","    int d = cdepth[v];","    for (int i : order) {","      dist[i][d] = depth[i];","      f[i][d] = aux[i];","    }","  }","","  void dfs_cent(int v, int p) {","    // v: the centroid of its current component","    // p: parent in centroid tree","    cpv[v] = p;","    calculate(v);","    subtree[v] = 1;  // HERE: init centroid subtree calculation","    for (int id : g[v]) {","      const auto& e = edges[id];","      int u = e.from ^ e.to ^ v;","      if (cdepth[u] != -1) {","        continue;","      }","      int c = find_centroid(u);","      cdepth[c] = cdepth[v] + 1;","      dfs_cent(c, v);","      subtree[v] += subtree[u];  // HERE: calculate based on child","    }","  }","","  void build_centroid() {","    int c = find_centroid(0);","    cdepth[c] = 0;","    dfs_cent(c, -1);","  }","};"],
        "description": "Centroid",
    }
    ,
    "Manacher": {
        "scope": "cpp",
        "prefix": "manacher",
        "body": ["template <typename T>","vector<int> manacher(int n, const T& s) {","  if (n == 0) {","    return vector<int>();","  }","  vector<int> res(2 * n - 1, 0);","  int l = -1, r = -1;","  for (int z = 0; z < 2 * n - 1; z++) {","    int i = (z + 1) >> 1;","    int j = z >> 1;","    int k = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));","    while (j + k + 1 < n && i - k - 1 >= 0 && s[j + k + 1] == s[i - k - 1]) {","      k++;","      l = i - k;","      r = j + k;","    }","    res[z] = k;","  }","  return res;","}","","template <typename T>","vector<int> manacher(const T& s) {","  return manacher((int) s.size(), s);","}"],
        "description": "Manacher",
    }
    ,
    "Kmp": {
        "scope": "cpp",
        "prefix": "kmp",
        "body": ["template <typename T>","vector<int> table(int m, const T& w) {","  // p[i] is the length of the longest substring of w ending at index i","  // which is also a prefix of w","  // the variable names 'm' and 'w' are chosen to reflect that this","  // function should be called on the search word, NOT the text","  // (fail from Codeforces 1466G)","  vector<int> p(m, 0);","  int k = 0;","  for (int i = 1; i < m; i++) {","    while (k > 0 && !(w[i] == w[k])) {","      k = p[k - 1];","    }","    if (w[i] == w[k]) {","      k++;","    }","    p[i] = k;","  }","  return p;","}","","template <typename T>","vector<int> table(const T& s) {","  return table((int) s.size(), s);","}","","template <typename T>","vector<int> search(int n, const T& s, int m, const T& w, const vector<int>& p) {","  assert(m > 0);","  vector<int> res;","  int k = 0;","  for (int i = 0; i < n; i++) {","    while (k == m || (k > 0 && !(s[i] == w[k]))) {","      k = p[k - 1];","    }","    if (s[i] == w[k]) {","      k++;","    }","    if (k == m) {","      res.push_back(i - m + 1);","    }","  }","  return res;  // returns 0-indexed positions of w in s","}","","template <typename T>","vector<int> search(const T& s, const T& w, const vector<int>& p) {","  return search((int) s.size(), s, (int) w.size(), w, p);","}","","template <typename T>","vector<int> search(const T& s, const T& w) {","  return search(s, w, table(w));","}"],
        "description": "Kmp",
    }
    ,
    "Aho Corasick Benq": {
        "scope": "cpp",
        "prefix": "ahocorasickbenq",
        "body": ["template <int SZ>","struct AhoCorasick {","  int sz = 1;","  int link[SZ];","  int ind[SZ];","  map<char, int> to[SZ], TO[SZ];","  int st[SZ], en[SZ];","  vector<int> child[SZ];","","  int add(string s) {  // add word","    int v = 0;","    for (const auto& c : s) {","      if (!to[v].count(c)) {","        to[v][c] = sz++;","      }","      v = to[v][c];","    }","    return v;","  }","","  int nex(int j, char c) {  // state after adding character","    // if alphabet size is limited, speed up with memoization","    while (j != -1 && !to[j].count(c)) {","      j = link[j];","    }","    return (j == -1 ? 0 : to[j][c]);","  }","","  int NEX(int j, char c) {","    if (TO[j].count(c)) {","      return TO[j][c];","    }","    return 0;","  }","","  int cnt = 0;","","  void dfs(int x) {","    st[x] = ++cnt;","    for (int t : child[x]) {","      dfs(t);","    }","    en[x] = cnt;","  }","","  void init() {  // generate links","    link[0] = -1;","    queue<int> q;","    q.push(0);","    TO[0] = to[0];","    while (!q.empty()) {","      int v = q.front();","      q.pop();","      for (const auto& it : to[v]) {","        char c = it.first;","        int u = it.second;","        link[u] = nex(link[v], c);","        TO[u] = TO[link[u]];","        for (const auto& t : to[u]) {","          TO[u][t.first] = t.second;","        }","        q.push(u);","      }","    }","    for (int i = 1; i < sz; i++) {","      child[link[i]].push_back(i);","    }","    dfs(0);","  }","};"],
        "description": "Aho Corasick Benq",
    }
    ,
    "Z Array": {
        "scope": "cpp",
        "prefix": "zarray",
        "body": ["template <typename T>","vector<int> z_array(T s) {","  int n = (int) s.size();","  vector<int> z(n, n);","  int l = 0, r = 0;","  for (int i = 1; i < n; i++) {","    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));","    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {","      l = i;","      r = i + z[i];","      z[i]++;","    }","  }","  return z;","}"],
        "description": "Z Array",
    }
    ,
    "Suffix Array": {
        "scope": "cpp",
        "prefix": "suffixarray",
        "body": ["template <typename T>","vector<int> suffix_array(int n, const T& s) {","  vector<int> a(n);","  if (n == 0) {","    return a;","  }","  iota(a.begin(), a.end(), 0);","  sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });","  vector<int> group(n);","  group[a[0]] = 0;","  for (int i = 1; i < n; i++) {","    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));","  }","  vector<int> sorted_by_second(n);","  vector<int> new_group(n);","  vector<int> ptr(n);","  int cnt = group[a[n - 1]] + 1;  // number of groups","  int step = 1;","  while (cnt < n) {","    int at = 0;","    for (int i = n - step; i < n; i++) {","      sorted_by_second[at++] = i;","    }","    for (int i = 0; i < n; i++) {","      if (a[i] - step >= 0) {","        sorted_by_second[at++] = a[i] - step;","      }","    }","    for (int i = n - 1; i >= 0; i--) {","      ptr[group[a[i]]] = i;","    }","    for (int x : sorted_by_second) {","      a[ptr[group[x]]++] = x;","    }","    new_group[a[0]] = 0;","    for (int i = 1; i < n; i++) {","      if (group[a[i]] != group[a[i - 1]]) {","        new_group[a[i]] = new_group[a[i - 1]] + 1;","      } else {","        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);","        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);","        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);","        // we will not have a case with pre == -1 and cur == -1","      }","    }","    swap(group, new_group);","    cnt = group[a[n - 1]] + 1;","    step <<= 1;","  }","  return a;","}","","template <typename T>","vector<int> suffix_array(const T& s) {","  return suffix_array((int) s.size(), s);","}","","/*","template <typename T>","pair<int, int> find_range(const vector<int>& sa, const T& s, const T& w) {","  int n = (int) sa.size();","  int m = (int) w.size();","  auto Compare = [&](int suf) {","    // compare the substring starting at suf of length at most m","    // -1 - w is smaller","    // 1 - w is larger","    // 0 - equal","    for (int i = 0; i < m; i++) {","      int pos = suf + i;","      if (pos == n || w[i] > s[pos]) {","        return 1;","      }","      if (w[i] < s[pos]) {","        return -1;","      }","    }","    return 0;","  };","  int low = 0, high = n;","  while (low < high) {","    int mid = (low + high) >> 1;","    if (Compare(sa[mid]) == 1) {","      low = mid + 1;","    } else {","      high = mid;","    }","  }","  int from = low;","  low = -1, high = n - 1;","  while (low < high) {","    int mid = (low + high + 1) >> 1;","    if (Compare(sa[mid]) == -1) {","      high = mid - 1;","    } else {","      low = mid;","    }","  }","  int to = low;","  if (from > to) {","    return {-1, -1};","  }","  return {from, to};","  // returns an interval [L, R] such that suffixes","  // sa[L], sa[L + 1], ..., sa[R] begin with w","}","*/","","template <typename T>","vector<int> find_lcp(int n, const T& s, const vector<int>& sa) {","  // Kasai's algorithm","  if (n <= 1) {","    return vector<int>();","  }","  vector<int> lcp(n - 1);","  vector<int> pos(n);","  for (int i = 0; i < n; i++) {","    pos[sa[i]] = i;","  }","  int k = 0;","  for (int i = 0; i < n; i++) {","    if (pos[i] == n - 1) {","      k = 0;","    } else {","      k = max(k - 1, 0);  // the last two \"windows\" become one shorter","      int j = sa[pos[i] + 1];","      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {","        ++k;","      }","      lcp[pos[i]] = k;","    }","  }","  return lcp;","}","","template <typename T>","vector<int> find_lcp(const T& s, const vector<int>& sa) {","  return find_lcp((int) s.size(), s, sa);","}"],
        "description": "Suffix Array",
    }
    ,
    "Suffix Automaton": {
        "scope": "cpp",
        "prefix": "suffixautomaton",
        "body": ["const int N = 100005;  // max|S|","const int NN = 2 * N;  // maximum number of nodes (states)","","using AlphaType = char;","","int nodes;","// int succ[2 * N][ALPHA];","map<AlphaType, int> succ[NN];","int link[NN];","int length[NN];","bool is_end[NN];  // whether some suffix ends here","","template <typename T>","void BuildAutomaton(const T& s) {","  // init automaton","  nodes = 0;","  link[nodes] = -1;","  length[nodes] = 0;","  ++nodes;","","  // build, one character at a time","  int last = 0;  // node corresponding to the whole string so far","  for (AlphaType c : s) {","    int id = nodes++;","    length[id] = length[last] + 1;","    int v = last;","    while (v != -1 && !succ[v].count(c)) {","      succ[v][c] = id;","      v = link[v];","    }","    if (v == -1) {","      link[id] = 0;","    } else {","      int to = succ[v][c];","      if (length[to] == length[v] + 1) {","        // continuous","        link[id] = to;","      } else {","        // clone node v","        int u = nodes++;","        succ[u] = succ[v];","        link[u] = link[v];","        length[u] = length[v] + 1;","        while (v != -1 && succ[v].count(c)) {","          succ[v][c] = u;","          v = link[v];","        }","        link[id] = u;","        link[to] = u;","      }","    }","    last = id;","  }","  int v = last;","  while (v != 0) {","    is_end[v] = true;","    v = link[v];","  }","  // TODO: understand this lol","}"],
        "description": "Suffix Automaton",
    }
    ,
    "Pbds": {
        "scope": "cpp",
        "prefix": "pbds",
        "body": ["#include <ext/pb_ds/assoc_container.hpp>","","using namespace __gnu_pbds;","","template <typename T>","using indexed_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"],
        "description": "Pbds",
    }
    ,
    "Fast Io": {
        "scope": "cpp",
        "prefix": "fastio",
        "body": ["ios::sync_with_stdio(0);","cin.tie(0);"],
        "description": "Fast Io",
    }
    ,
    "Rng": {
        "scope": "cpp",
        "prefix": "rng",
        "body": ["mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());","","int RandInt(int low, int high) {","  return low + (rng() % (high - low + 1));","}"],
        "description": "Rng",
    }
    ,
    "Print Ans": {
        "scope": "cpp",
        "prefix": "printans",
        "body": ["for (int i = 0; i < (int) ${1:ans}.size(); i++) {","  if (i > 0) {","    cout << ' ';","  }","  cout << $1[i]$2;","}","cout << '\\n';"],
        "description": "Print Ans",
    }
    ,
    "Fwht": {
        "scope": "cpp",
        "prefix": "fwht",
        "body": ["namespace fwht {","  ","template<typename T>","void hadamard(vector<T> &a) {","  int n = a.size();","  for (int k = 1; k < n; k <<= 1) {","    for (int i = 0; i < n; i += 2 * k) {","      for (int j = 0; j < k; j++) {","        T x = a[i + j];","        T y = a[i + j + k];","        a[i + j] = x + y;","        a[i + j + k] = x - y;","      }","    }","  }","}","","template<typename T>","vector<T> multiply(vector<T> a, vector<T> b) {","  int eq = (a == b);","  int n = 1;","  while (n < (int) max(a.size(), b.size())) {","    n <<= 1;","  }","  a.resize(n);","  b.resize(n);","  hadamard(a);","  if (eq) b = a; else hadamard(b);","  for (int i = 0; i < n; i++) {","    a[i] *= b[i];","  }","  hadamard(a);","  T q = 1 / static_cast<T>(n);","  for (int i = 0; i < n; i++) {","    a[i] *= q;","  }","  return a;","}","","}  // namespace fwht"],
        "description": "Fwht",
    }
    ,
    "Matrix": {
        "scope": "cpp",
        "prefix": "matrix",
        "body": ["template <typename T>","class Matrix : public vector<vector<T>> {"," public:","  int n, m;","  ","  // initialization order is the order the values are defined","  // in the class, not the order we write the initializations","  Matrix(int _n, int _m) : vector<vector<T>>(_n, vector<T>(_m)), n(_n), m(_m) {","    assert(n > 0 && m > 0);","  }","};","","using Mat = Matrix<${1:int}>;","// for vectors, just declare an n-by-1 Mat","","Mat Identity(int n) {","  Mat res(n, n);","  for (int i = 0; i < n; i++) {","    res[i][i] = 1;","  }","  return res;","}","","Mat mul(const Mat& a, const Mat& b) {","  assert(a.m == b.n);","  Mat res(a.n, b.m);","  for (int i = 0; i < a.n; i++) {","    for (int j = 0; j < b.m; j++) {","      for (int k = 0; k < a.m; k++) {","        res[i][j] += a[i][k] * b[k][j];","      }","    }","  }","  return res;","}","","Mat power(Mat a, long long b) {","  assert(a.n == a.m);","  Mat res = Identity(a.n);","  while (b > 0) {","    if (b & 1) {","      res = mul(res, a);","    }","    a = mul(a, a);","    b >>= 1;","  }","  return res;","}"],
        "description": "Matrix",
    }
    ,
    "Fraction": {
        "scope": "cpp",
        "prefix": "fraction",
        "body": ["template <typename T>","class Fraction {"," public:","  static constexpr bool AUTO_REDUCE = ${1:false};","","  T num;","  T den;","","  void normalize() {","    if (AUTO_REDUCE) {","      T g = __gcd(num, den);","      num /= g;","      den /= g;","    }","    if (den < 0) {","      num = -num;","      den = -den;","    }","  }","","  Fraction() : num(0), den(1) {}","  Fraction(const T& n) : num(n), den(1) {}","  Fraction(const T& _num, const T& _den) : num(_num), den(_den) {","    assert(den != 0);","    normalize();","  }","","  // double eval() {","  //   return (double) num / den;","  // }","","  Fraction& operator+=(const Fraction& other) {","    if (den % other.den == 0) {","      num = num + other.num * den / other.den;","    } else if (other.den % den == 0) {","      num = other.num + num * other.den / den;","      den = other.den;","    } else {","      num = num * other.den + den * other.num;","      den *= other.den;","    }","    normalize();","    return *this;","  }","","  Fraction& operator-=(const Fraction& other) {","    if (den % other.den == 0) {","      num = num - other.num * den / other.den;","    } else if (other.den % den == 0) {","      num = -other.num + num * other.den / den;","      den = other.den;","    } else {","      num = num * other.den - den * other.num;","      den *= other.den;","    }","    normalize();","    return *this;","  }","","  Fraction& operator*=(const Fraction& other) {","    num *= other.num;","    den *= other.den;","    normalize();","    return *this;","  }","","  Fraction& operator/=(const Fraction& other) {","    assert(other.num != 0);","    num *= other.den;","    den *= other.num;","    normalize();","    return *this;","  }","","  template <typename U>","  Fraction& operator+=(const U& other) { return *this += Fraction(other); }","  template <typename U>","  Fraction& operator-=(const U& other) { return *this -= Fraction(other); }","  template <typename U>","  Fraction& operator*=(const U& other) { return *this *= Fraction(other); }","  template <typename U>","  Fraction& operator/=(const U& other) { return *this /= Fraction(other); }","  Fraction operator-() const { return Fraction(-num, den); }","  Fraction operator+() const { return *this; }","};","","template <typename T>","bool operator==(const Fraction<T>& lhs, const Fraction<T>& rhs) {","  if (Fraction<T>::AUTO_REDUCE) {","    return lhs.num == rhs.num && lhs.den == rhs.den;","  }","  return lhs.num * rhs.den == rhs.num * lhs.den;","}","template <typename T, typename U>","bool operator==(const Fraction<T>& lhs, U rhs) { return lhs == Fraction<T>(rhs); }","template <typename T, typename U>","bool operator==(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) == rhs; }","","template <typename T>","bool operator!=(const Fraction<T>& lhs, const Fraction<T>& rhs) { return !(lhs == rhs); }","template <typename T, typename U>","bool operator!=(const Fraction<T>& lhs, U rhs) { return !(lhs == rhs); }","template <typename T, typename U>","bool operator!=(U lhs, const Fraction<T>& rhs) { return !(lhs == rhs); }","","template <typename T>","bool operator<(const Fraction<T>& lhs, const Fraction<T>& rhs) { return lhs.num * rhs.den < rhs.num * lhs.den; }","template <typename T, typename U>","bool operator<(const Fraction<T>& lhs, U rhs) { return lhs < Fraction<T>(rhs); }","template <typename T, typename U>","bool operator<(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) < rhs; }","","template <typename T>","bool operator<=(const Fraction<T>& lhs, const Fraction<T>& rhs) { return lhs.num * rhs.den <= rhs.num * lhs.den; }","template <typename T, typename U>","bool operator<=(const Fraction<T>& lhs, U rhs) { return lhs <= Fraction<T>(rhs); }","template <typename T, typename U>","bool operator<=(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) <= rhs; }","","template <typename T>","bool operator>(const Fraction<T>& lhs, const Fraction<T>& rhs) { return lhs.num * rhs.den > rhs.num * lhs.den; }","template <typename T, typename U>","bool operator>(const Fraction<T>& lhs, U rhs) { return lhs > Fraction<T>(rhs); }","template <typename T, typename U>","bool operator>(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) > rhs; }","","template <typename T>","bool operator>=(const Fraction<T>& lhs, const Fraction<T>& rhs) { return lhs.num * rhs.den >= rhs.num * lhs.den; }","template <typename T, typename U>","bool operator>=(const Fraction<T>& lhs, U rhs) { return lhs >= Fraction<T>(rhs); }","template <typename T, typename U>","bool operator>=(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) >= rhs; }","","template <typename T>","Fraction<T> operator+(const Fraction<T>& lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) += rhs; }","template <typename T, typename U>","Fraction<T> operator+(const Fraction<T>& lhs, U rhs) { return Fraction<T>(lhs) += rhs; }","template <typename T, typename U>","Fraction<T> operator+(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) += rhs; }","","template <typename T>","Fraction<T> operator-(const Fraction<T>& lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) -= rhs; }","template <typename T, typename U>","Fraction<T> operator-(const Fraction<T>& lhs, U rhs) { return Fraction<T>(lhs) -= rhs; }","template <typename T, typename U>","Fraction<T> operator-(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) -= rhs; }","","template <typename T>","Fraction<T> operator*(const Fraction<T>& lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) *= rhs; }","template <typename T, typename U>","Fraction<T> operator*(const Fraction<T>& lhs, U rhs) { return Fraction<T>(lhs) *= rhs; }","template <typename T, typename U>","Fraction<T> operator*(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) *= rhs; }","","template <typename T>","Fraction<T> operator/(const Fraction<T>& lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) /= rhs; }","template <typename T, typename U>","Fraction<T> operator/(const Fraction<T>& lhs, U rhs) { return Fraction<T>(lhs) /= rhs; }","template <typename T, typename U>","Fraction<T> operator/(U lhs, const Fraction<T>& rhs) { return Fraction<T>(lhs) /= rhs; }","","template <typename T>","T floor(const Fraction<T>& f) {","  T res = f.num / f.den;","  if ((f.num ^ f.den) < 0 && res * f.den != f.num) {","    res -= 1;","  }","  return res;","}","","template <typename T>","Fraction<T> abs(const Fraction<T>& f) {","  __int128 a = (f.num >= 0 ? f.num : -f.num);","  return Fraction<T>(a, f.den);","}","","template <typename T>","string to_string(const Fraction<T>& f) {","  return to_string(f.num) + \" / \" + to_string(f.den);","}","","using F = Fraction<${2:__int128}>;"],
        "description": "Fraction",
    }
    ,
    "Modular": {
        "scope": "cpp",
        "prefix": "modular",
        "body": ["namespace modular {","","// const int md = 998244353;","const int md = (int) 1e9 + 7;","","inline void add(int& a, const int b) {","  a += b;","  if (a >= md) {","    a -= md;","  }","}","","inline void sub(int& a, const int b) {","  a -= b;","  if (a < 0) {","    a += md;","  }","}","","inline int mul(int a, int b) {","  return (int) ((long long) a * b % md);","}","","inline int power(int a, long long b) {","  a %= md;","  if (a < 0) {","    a += md;","  }","  int res = 1;","  while (b > 0) {","    if (b & 1) {","      res = mul(res, a);","    }","    a = mul(a, a);","    b >>= 1;","  }","  return res;","}","","inline int inverse(int a) {","  a %= md;","  if (a < 0) {","    a += md;","  }","  int b = md, u = 0, v = 1;","  while (a > 0) {","    int q = b / a;","    b -= q * a;","    swap(a, b);","    u -= q * v;","    swap(u, v);","  }","  assert(b == 1);  // b = gcd(a, md)","  if (u < 0) {","    u += md;","  }","  return u;","}","","}  // namespace modular","","using namespace modular;"],
        "description": "Modular",
    }
    ,
    "Extgcd": {
        "scope": "cpp",
        "prefix": "extgcd",
        "body": ["template<typename T>","T extgcd(T a, T b, T &x, T &y) {","  if (a == 0) {","    x = 0;","    y = 1;","    return b;","  }","  T p = b / a;","  T g = extgcd(b - p * a, a, y, x);","  x -= p * y;","  return g;","}","","template<typename T>","bool diophantine(T a, T b, T c, T &x, T &y, T &g) {","  if (a == 0 && b == 0) {","    if (c == 0) {","      x = y = g = 0;","      return true;","    }","    return false;","  }","  if (a == 0) {","    if (c % b == 0) {","      x = 0;","      y = c / b;","      g = abs(b);","      return true;","    }","    return false;","  }","  if (b == 0) {","    if (c % a == 0) {","      x = c / a;","      y = 0;","      g = abs(a);","      return true;","    }","    return false;","  }","  g = extgcd(a, b, x, y);","  if (c % g != 0) {","    return false;","  }","  T dx = c / a;","  c -= dx * a;","  T dy = c / b;","  c -= dy * b;","  x = dx + (T) ((__int128) x * (c / g) % b);","  y = dy + (T) ((__int128) y * (c / g) % a);","  g = abs(g);","  return true;","  // |x|, |y| <= max(|a|, |b|, |c|) [tested]","}","","bool crt(long long k1, long long m1, long long k2, long long m2, long long &k, long long &m) {","  k1 %= m1;","  if (k1 < 0) k1 += m1;","  k2 %= m2;","  if (k2 < 0) k2 += m2;","  long long x, y, g;","  if (!diophantine(m1, -m2, k2 - k1, x, y, g)) {","    return false;","  }","  long long dx = m2 / g;","  long long delta = x / dx - (x % dx < 0);","  k = m1 * (x - dx * delta) + k1;","  m = m1 / g * m2;","  assert(0 <= k && k < m);","  return true;","}"],
        "description": "Extgcd",
    }
    ,
    "Ntt": {
        "scope": "cpp",
        "prefix": "ntt",
        "body": ["template <typename T>","class NTT {"," public:","  using Type = typename decay<decltype(T::value)>::type;","","  static Type md;","  static Modular<T> root;","  static int base;","  static int max_base;","  static vector<Modular<T>> roots;","  static vector<int> rev;","","  static void clear() {","    root = 0;","    base = 0;","    max_base = 0;","    roots.clear();","    rev.clear();","  }","","  static void init() {","    md = T::value;","    assert(md >= 3 && md % 2 == 1);","    auto tmp = md - 1;","    max_base = 0;","    while (tmp % 2 == 0) {","      tmp /= 2;","      max_base++;","    }","    root = 2;","    while (power(root, (md - 1) >> 1) == 1) {","      root++;","    }","    assert(power(root, md - 1) == 1);","    root = power(root, (md - 1) >> max_base);","    base = 1;","    rev = {0, 1};","    roots = {0, 1};","  }","","  static void ensure_base(int nbase) {","    if (md != T::value) {","      clear();","    }","    if (roots.empty()) {","      init();","    }","    if (nbase <= base) {","      return;","    }","    assert(nbase <= max_base);","    rev.resize(1 << nbase);","    for (int i = 0; i < (1 << nbase); i++) {","      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));","    }","    roots.resize(1 << nbase);","    while (base < nbase) {","      Modular<T> z = power(root, 1 << (max_base - 1 - base));","      for (int i = 1 << (base - 1); i < (1 << base); i++) {","        roots[i << 1] = roots[i];","        roots[(i << 1) + 1] = roots[i] * z;","      }","      base++;","    }","  }","","  static void fft(vector<Modular<T>>& a) {","    int n = (int) a.size();","    assert((n & (n - 1)) == 0);","    int zeros = __builtin_ctz(n);","    ensure_base(zeros);","    int shift = base - zeros;","    for (int i = 0; i < n; i++) {","      if (i < (rev[i] >> shift)) {","        swap(a[i], a[rev[i] >> shift]);","      }","    }","    for (int k = 1; k < n; k <<= 1) {","      for (int i = 0; i < n; i += 2 * k) {","        for (int j = 0; j < k; j++) {","          Modular<T> x = a[i + j];","          Modular<T> y = a[i + j + k] * roots[j + k];","          a[i + j] = x + y;","          a[i + j + k] = x - y;","        }","      }","    }","  }","","  static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {","    if (a.empty() || b.empty()) {","      return {};","    }","    int eq = (a == b);","    int need = (int) a.size() + (int) b.size() - 1;","    int nbase = 0;","    while ((1 << nbase) < need) nbase++;","    ensure_base(nbase);","    int sz = 1 << nbase;","    a.resize(sz);","    b.resize(sz);","    fft(a);","    if (eq) {","      b = a;","    } else {","      fft(b);","    }","    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);","    for (int i = 0; i < sz; i++) {","      a[i] *= b[i] * inv_sz;","    }","    reverse(a.begin() + 1, a.end());","    fft(a);","    a.resize(need);","    return a;","  }","};","","template <typename T> typename NTT<T>::Type NTT<T>::md;","template <typename T> Modular<T> NTT<T>::root;","template <typename T> int NTT<T>::base;","template <typename T> int NTT<T>::max_base;","template <typename T> vector<Modular<T>> NTT<T>::roots;","template <typename T> vector<int> NTT<T>::rev;","","template <typename T>","vector<Modular<T>> inverse(const vector<Modular<T>>& a) {","  assert(!a.empty());","  int n = (int) a.size();","  vector<Modular<T>> b = {1 / a[0]};","  while ((int) b.size() < n) {","    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));","    x.resize(b.size() << 1);","    b.resize(b.size() << 1);","    vector<Modular<T>> c = b;","    NTT<T>::fft(c);","    NTT<T>::fft(x);","    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());","    for (int i = 0; i < (int) x.size(); i++) {","      x[i] *= c[i] * inv;","    }","    reverse(x.begin() + 1, x.end());","    NTT<T>::fft(x);","    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());","    fill(x.begin() + (x.size() >> 1), x.end(), 0);","    NTT<T>::fft(x);","    for (int i = 0; i < (int) x.size(); i++) {","      x[i] *= c[i] * inv;","    }","    reverse(x.begin() + 1, x.end());","    NTT<T>::fft(x);","    for (int i = 0; i < ((int) x.size() >> 1); i++) {","      b[i + ((int) x.size() >> 1)] = -x[i];","    }","  }","  b.resize(n);","  return b;","}","","template <typename T>","vector<Modular<T>> inverse_old(vector<Modular<T>> a) {","  assert(!a.empty());","  int n = (int) a.size();","  if (n == 1) {","    return {1 / a[0]};","  }","  int m = (n + 1) >> 1;","  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));","  int need = n << 1;","  int nbase = 0;","  while ((1 << nbase) < need) {","    ++nbase;","  }","  NTT<T>::ensure_base(nbase);","  int size = 1 << nbase;","  a.resize(size);","  b.resize(size);","  NTT<T>::fft(a);","  NTT<T>::fft(b);","  Modular<T> inv = 1 / static_cast<Modular<T>>(size);","  for (int i = 0; i < size; ++i) {","    a[i] = (2 - a[i] * b[i]) * b[i] * inv;","  }","  reverse(a.begin() + 1, a.end());","  NTT<T>::fft(a);","  a.resize(n);","  return a;","}","","template <typename T>","vector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {","  if (a.empty() || b.empty()) {","    return {};","  }","  if (min(a.size(), b.size()) < 150) {","    vector<Modular<T>> c(a.size() + b.size() - 1, 0);","    for (int i = 0; i < (int) a.size(); i++) {","      for (int j = 0; j < (int) b.size(); j++) {","        c[i + j] += a[i] * b[j];","      }","    }","    return c;","  }","  return NTT<T>::multiply(a, b);","}","","template <typename T>","vector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {","  return a = a * b;","}"],
        "description": "Ntt",
    }
    ,
    "Mint": {
        "scope": "cpp",
        "prefix": "mint",
        "body": ["template <typename T>","T inverse(T a, T m) {","  T u = 0, v = 1;","  while (a != 0) {","    T t = m / a;","    m -= t * a;","    swap(a, m);","    u -= t * v;","    swap(u, v);","  }","  assert(m == 1);","  return u;","}","","template <typename T>","class Modular {"," public:","  using Type = typename decay<decltype(T::value)>::type;","","  constexpr Modular() : value() {}","  template <typename U>","  Modular(const U& x) {","    value = normalize(x);","  }","","  template <typename U>","  static Type normalize(const U& x) {","    Type v;","    if (-mod() <= x && x < mod())","      v = static_cast<Type>(x);","    else","      v = static_cast<Type>(x % mod());","    if (v < 0) v += mod();","    return v;","  }","","  const Type& operator()() const { return value; }","  template <typename U>","  explicit operator U() const { return static_cast<U>(value); }","  constexpr static Type mod() { return T::value; }","","  Modular& operator+=(const Modular& other) {","    if ((value += other.value) >= mod()) value -= mod();","    return *this;","  }","  Modular& operator-=(const Modular& other) {","    if ((value -= other.value) < 0) value += mod();","    return *this;","  }","  template <typename U>","  Modular& operator+=(const U& other) { return *this += Modular(other); }","  template <typename U>","  Modular& operator-=(const U& other) { return *this -= Modular(other); }","  Modular& operator++() { return *this += 1; }","  Modular& operator--() { return *this -= 1; }","  Modular operator++(int) {","    Modular result(*this);","    *this += 1;","    return result;","  }","  Modular operator--(int) {","    Modular result(*this);","    *this -= 1;","    return result;","  }","  Modular operator-() const { return Modular(-value); }","  Modular operator+() const { return Modular(value); } // controversial?","","  template <typename U = T>","  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {","#ifdef _WIN32","    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);","    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;","    asm(","        \"divl %4; \\n\\t\"","        : \"=a\"(d), \"=d\"(m)","        : \"d\"(xh), \"a\"(xl), \"r\"(mod()));","    value = m;","#else","    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));","#endif","    return *this;","  }","  template <typename U = T>","  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {","    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());","    value = normalize(value * rhs.value - q * mod());","    return *this;","  }","  template <typename U = T>","  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {","    value = normalize(value * rhs.value);","    return *this;","  }","","  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }","","  friend const Type& abs(const Modular& x) { return x.value; }","","  template <typename U>","  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);","","  template <typename U>","  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);","","  template <typename V, typename U>","  friend V& operator>>(V& stream, Modular<U>& number);",""," private:","  Type value;","};","","template <typename T>","bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }","template <typename T, typename U>","bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }","template <typename T, typename U>","bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }","","template <typename T>","bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }","template <typename T, typename U>","bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }","template <typename T, typename U>","bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }","","template <typename T>","bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }","","template <typename T>","Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }","template <typename T, typename U>","Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }","template <typename T, typename U>","Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }","","template <typename T>","Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }","template <typename T, typename U>","Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }","template <typename T, typename U>","Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }","","template <typename T>","Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }","template <typename T, typename U>","Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }","template <typename T, typename U>","Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }","","template <typename T>","Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }","template <typename T, typename U>","Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }","template <typename T, typename U>","Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }","","template <typename T, typename U>","Modular<T> power(const Modular<T>& a, const U& b) {","  assert(b >= 0);","  Modular<T> x = a, res = 1;","  U p = b;","  while (p > 0) {","    if (p & 1) res *= x;","    x *= x;","    p >>= 1;","  }","  return res;","}","","template <typename T>","bool IsZero(const Modular<T>& number) {","  return number() == 0;","}","","template <typename T>","string to_string(const Modular<T>& number) {","  return to_string(number());","}","","// U == std::ostream? but done this way because of fastoutput","template <typename U, typename T>","U& operator<<(U& stream, const Modular<T>& number) {","  return stream << number();","}","","// U == std::istream? but done this way because of fastinput","template <typename U, typename T>","U& operator>>(U& stream, Modular<T>& number) {","  typename common_type<typename Modular<T>::Type, long long>::type x;","  stream >> x;","  number.value = Modular<T>::normalize(x);","  return stream;","}","","constexpr int md = ${1:(int) 1e9 + 7};","using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;","","vector<Mint> fact(1, 1);","vector<Mint> inv_fact(1, 1);","","Mint C(int n, int k) {","  if (k < 0 || k > n) {","    return 0;","  }","  while ((int) fact.size() < n + 1) {","    fact.push_back(fact.back() * (int) fact.size());","    inv_fact.push_back(1 / fact.back());","  }","  return fact[n] * inv_fact[k] * inv_fact[n - k];","}"],
        "description": "Mint",
    }
    ,
    "Square Matrix": {
        "scope": "cpp",
        "prefix": "squarematrix",
        "body": ["constexpr int N = $1;","","template <typename T>","class Matrix : public array<array<T, N>, N> {"," public:","  Matrix() : array<array<T, N>, N>() {","    for (int i = 0; i < N; i++) {","      for (int j = 0; j < N; j++) {","        (*this)[i][j] = 0;","      }","    }","  }","};","","using Mat = Matrix<${2:int}>;","","Mat Identity() {","  Mat res;","  for (int i = 0; i < N; i++) {","    res[i][i] = 1;","  }","  return res;","}","","const Mat ID = Identity();","","Mat mul(const Mat& a, const Mat& b) {","  Mat res;","  for (int i = 0; i < N; i++) {","    for (int j = 0; j < N; j++) {","      for (int k = 0; k < N; k++) {","        res[i][j] += a[i][k] * b[k][j];","      }","    }","  }","  return res;","}","","Mat power(Mat a, long long b) {","  Mat res = ID;","  while (b > 0) {","    if (b & 1) {","      res = mul(res, a);","    }","    a = mul(a, a);","    b >>= 1;","  }","  return res;","}"],
        "description": "Square Matrix",
    }
    ,
    "Solve Linear": {
        "scope": "cpp",
        "prefix": "solvelinear",
        "body": ["template <typename T>","vector<T> gaussian(int n, vector<vector<T>> a, vector<T> v) {","  for (int i = 0; i < n; i++) {","    if (a[i][i] == 0) {  // check this for doubles","      for (int j = i + 1; j < n; j++) {","        if (a[j][i] != 0) {","          swap(a[i], a[j]);","          swap(v[i], v[j]);","          break;","        }","      }","    }","    if (a[i][i] == 0) {","      return vector<T>();  // not full rank","    }","    v[i] /= a[i][i];","    for (int k = n - 1; k >= i; k--) {","      a[i][k] /= a[i][i];","    }","    for (int j = i + 1; j < n; j++) {","      T r = a[j][i];","      v[j] -= v[i] * r;","      for (int k = n - 1; k >= i; k--) {","        a[j][k] -= a[i][k] * r;","      }","    }","  }","  for (int i = n - 1; i >= 0; i--) {","    for (int j = i + 1; j < n; j++) {","      v[i] -= v[j] * a[i][j];","    }","  }","  return v;","}","","template <typename T>","vector<T> gaussian(const vector<vector<T>>& a, const vector<T>& v) {","  int n = (int) a.size();","  assert(n > 0);","  assert((int) a[0].size() == n);","  assert((int) v.size() == n);","  return gaussian(n, a, v);","}"],
        "description": "Solve Linear",
    }
    ,
    "Poly": {
        "scope": "cpp",
        "prefix": "poly",
        "body": ["template <typename T>","vector<T>& operator+=(vector<T>& a, const vector<T>& b) {","  if (a.size() < b.size()) {","    a.resize(b.size());","  }","  for (int i = 0; i < (int) b.size(); i++) {","    a[i] += b[i];","  }","  return a;","}","","template <typename T>","vector<T> operator+(const vector<T>& a, const vector<T>& b) {","  vector<T> c = a;","  return c += b;","}","","template <typename T>","vector<T>& operator-=(vector<T>& a, const vector<T>& b) {","  if (a.size() < b.size()) {","    a.resize(b.size());","  }","  for (int i = 0; i < (int) b.size(); i++) {","    a[i] -= b[i];","  }","  return a;","}","","template <typename T>","vector<T> operator-(const vector<T>& a, const vector<T>& b) {","  vector<T> c = a;","  return c -= b;","}","","template <typename T>","vector<T> operator-(const vector<T>& a) {","  vector<T> c = a;","  for (int i = 0; i < (int) c.size(); i++) {","    c[i] = -c[i];","  }","  return c;","}","","template <typename T>","vector<T> operator*(const vector<T>& a, const vector<T>& b) {","  if (a.empty() || b.empty()) {","    return {};","  }","  vector<T> c(a.size() + b.size() - 1, 0);","  for (int i = 0; i < (int) a.size(); i++) {","    for (int j = 0; j < (int) b.size(); j++) {","      c[i + j] += a[i] * b[j];","    }","  }","  return c;","}","","template <typename T>","vector<T>& operator*=(vector<T>& a, const vector<T>& b) {","  return a = a * b;","}","","template <typename T>","vector<T> inverse(const vector<T>& a) {","  assert(!a.empty());","  int n = (int) a.size();","  vector<T> b = {1 / a[0]};","  while ((int) b.size() < n) {","    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));","    vector<T> x = b * b * a_cut;","    b.resize(b.size() << 1);","    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {","      b[i] = -x[i];","    }","  }","  b.resize(n);","  return b;","}","","template <typename T>","vector<T>& operator/=(vector<T>& a, const vector<T>& b) {","  int n = (int) a.size();","  int m = (int) b.size();","  if (n < m) {","    a.clear();","  } else {","    vector<T> d = b;","    reverse(a.begin(), a.end());","    reverse(d.begin(), d.end());","    d.resize(n - m + 1);","    a *= inverse(d);","    a.erase(a.begin() + n - m + 1, a.end());","    reverse(a.begin(), a.end());","  }","  return a;","}","","template <typename T>","vector<T> operator/(const vector<T>& a, const vector<T>& b) {","  vector<T> c = a;","  return c /= b;","}","","template <typename T>","vector<T>& operator%=(vector<T>& a, const vector<T>& b) {","  int n = (int) a.size();","  int m = (int) b.size();","  if (n >= m) {","    vector<T> c = (a / b) * b;","    a.resize(m - 1);","    for (int i = 0; i < m - 1; i++) {","      a[i] -= c[i];","    }","  }","  return a;","}","","template <typename T>","vector<T> operator%(const vector<T>& a, const vector<T>& b) {","  vector<T> c = a;","  return c %= b;","}","","template <typename T, typename U>","vector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {","  assert(b >= 0);","  vector<U> binary;","  U bb = b;","  while (bb > 0) {","    binary.push_back(bb & 1);","    bb >>= 1;","  }","  vector<T> res = vector<T>{1} % c;","  for (int j = (int) binary.size() - 1; j >= 0; j--) {","    res = res * res % c;","    if (binary[j] == 1) {","      res = res * a % c;","    }","  }","  return res;","}","","template <typename T>","vector<T> derivative(const vector<T>& a) {","  vector<T> c = a;","  for (int i = 0; i < (int) c.size(); i++) {","    c[i] *= i;","  }","  if (!c.empty()) {","    c.erase(c.begin());","  }","  return c;","}"," ","template <typename T>","vector<T> primitive(const vector<T>& a) {","  vector<T> c = a;","  c.insert(c.begin(), 0);","  for (int i = 1; i < (int) c.size(); i++) {","    c[i] /= i;","  }","  return c;","}","","template <typename T>","vector<T> logarithm(const vector<T>& a) {","  assert(!a.empty() && a[0] == 1);","  vector<T> u = primitive(derivative(a) * inverse(a));","  u.resize(a.size());","  return u;","}"," ","template <typename T>","vector<T> exponent(const vector<T>& a) {","  assert(!a.empty() && a[0] == 0);","  int n = (int) a.size();","  vector<T> b = {1};","  while ((int) b.size() < n) {","    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));","    x[0] += 1;","    vector<T> old_b = b;","    b.resize(b.size() << 1);","    x -= logarithm(b);","    x *= old_b;","    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {","      b[i] = x[i];","    }","  }","  b.resize(n);","  return b;","}","","template <typename T>","vector<T> sqrt(const vector<T>& a) {","  assert(!a.empty() && a[0] == 1);","  int n = (int) a.size();","  vector<T> b = {1};","  while ((int) b.size() < n) {","    vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));","    b.resize(b.size() << 1);","    x *= inverse(b);","    T inv2 = 1 / static_cast<T>(2);","    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {","      b[i] = x[i] * inv2;","    }","  }","  b.resize(n);","  return b;","}","","template <typename T>","vector<T> multiply(const vector<vector<T>>& a) {","  if (a.empty()) {","    return {0};","  }","  function<vector<T>(int, int)> mult = [&](int l, int r) {","    if (l == r) {","      return a[l];","    }","    int y = (l + r) >> 1;","    return mult(l, y) * mult(y + 1, r);","  };","  return mult(0, (int) a.size() - 1);","}","","template <typename T>","T evaluate(const vector<T>& a, const T& x) {","  T res = 0;","  for (int i = (int) a.size() - 1; i >= 0; i--) {","    res = res * x + a[i];","  }","  return res;","}","","template <typename T>","vector<T> evaluate(const vector<T>& a, const vector<T>& x) {","  if (x.empty()) {","    return {};","  }","  if (a.empty()) {","    return vector<T>(x.size(), 0);","  }","  int n = (int) x.size();","  vector<vector<T>> st((n << 1) - 1);","  function<void(int, int, int)> build = [&](int v, int l, int r) {","    if (l == r) {","      st[v] = vector<T>{-x[l], 1};","    } else {","      int y = (l + r) >> 1;","      int z = v + ((y - l + 1) << 1);","      build(v + 1, l, y);","      build(z, y + 1, r);","      st[v] = st[v + 1] * st[z];","    }","  };","  build(0, 0, n - 1);","  vector<T> res(n);","  function<void(int, int, int, vector<T>)> eval = [&](int v, int l, int r, vector<T> f) {","    f %= st[v];","    if ((int) f.size() < 150) {","      for (int i = l; i <= r; i++) {","        res[i] = evaluate(f, x[i]);","      }","      return;","    }","    if (l == r) {","      res[l] = f[0];","    } else {","      int y = (l + r) >> 1;","      int z = v + ((y - l + 1) << 1);","      eval(v + 1, l, y, f);","      eval(z, y + 1, r, f);","    }","  };","  eval(0, 0, n - 1, a);","  return res;","}","","template <typename T>","vector<T> interpolate(const vector<T>& x, const vector<T>& y) {","  if (x.empty()) {","    return {};","  }","  assert(x.size() == y.size());","  int n = (int) x.size();","  vector<vector<T>> st((n << 1) - 1);","  function<void(int, int, int)> build = [&](int v, int l, int r) {","    if (l == r) {","      st[v] = vector<T>{-x[l], 1};","    } else {","      int w = (l + r) >> 1;","      int z = v + ((w - l + 1) << 1);","      build(v + 1, l, w);","      build(z, w + 1, r);","      st[v] = st[v + 1] * st[z];","    }","  };","  build(0, 0, n - 1);","  vector<T> m = st[0];","  vector<T> dm = derivative(m);","  vector<T> val(n);","  function<void(int, int, int, vector<T>)> eval = [&](int v, int l, int r, vector<T> f) {","    f %= st[v];","    if ((int) f.size() < 150) {","      for (int i = l; i <= r; i++) {","        val[i] = evaluate(f, x[i]);","      }","      return;","    }","    if (l == r) {","      val[l] = f[0];","    } else {","      int w = (l + r) >> 1;","      int z = v + ((w - l + 1) << 1);","      eval(v + 1, l, w, f);","      eval(z, w + 1, r, f);","    }","  };","  eval(0, 0, n - 1, dm);","  for (int i = 0; i < n; i++) {","    val[i] = y[i] / val[i];","  }","  function<vector<T>(int, int, int)> calc = [&](int v, int l, int r) {","    if (l == r) {","      return vector<T>{val[l]};","    }","    int w = (l + r) >> 1;","    int z = v + ((w - l + 1) << 1);","    return calc(v + 1, l, w) * st[z] + calc(z, w + 1, r) * st[v + 1];","  };","  return calc(0, 0, n - 1);","}","","// f[i] = 1^i + 2^i + ... + up^i","template <typename T>","vector<T> faulhaber(const T& up, int n) {","  vector<T> ex(n + 1);","  T e = 1;","  for (int i = 0; i <= n; i++) {","    ex[i] = e;","    e /= i + 1;","  }","  vector<T> den = ex;","  den.erase(den.begin());","  for (auto& d : den) {","    d = -d;","  }","  vector<T> num(n);","  T p = 1;","  for (int i = 0; i < n; i++) {","    p *= up + 1;","    num[i] = ex[i + 1] * (1 - p);","  }","  vector<T> res = num * inverse(den);","  res.resize(n);","  T f = 1;","  for (int i = 0; i < n; i++) {","    res[i] *= f;","    f *= i + 1;","  }","  return res;","}","","// (x + 1) * (x + 2) * ... * (x + n)","// (can be optimized with precomputed inverses)","template <typename T>","vector<T> sequence(int n) {","  if (n == 0) {","    return {1};","  }","  if (n % 2 == 1) {","    return sequence<T>(n - 1) * vector<T>{n, 1};","  }","  vector<T> c = sequence<T>(n / 2);","  vector<T> a = c;","  reverse(a.begin(), a.end());","  T f = 1;","  for (int i = n / 2 - 1; i >= 0; i--) {","    f *= n / 2 - i;","    a[i] *= f;","  }","  vector<T> b(n / 2 + 1);","  b[0] = 1;","  for (int i = 1; i <= n / 2; i++) {","    b[i] = b[i - 1] * (n / 2) / i;","  }","  vector<T> h = a * b;","  h.resize(n / 2 + 1);","  reverse(h.begin(), h.end());","  f = 1;","  for (int i = 1; i <= n / 2; i++) {","    f /= i;","    h[i] *= f;","  }","  vector<T> res = c * h;","  return res;","}","","template <typename T>","class OnlineProduct {"," public:","  const vector<T> a;","  vector<T> b;","  vector<T> c;","  OnlineProduct(const vector<T>& a_) : a(a_) {}","  T add(const T& val) {","    int i = (int) b.size();","    b.push_back(val);","    if ((int) c.size() <= i) {","      c.resize(i + 1);","    }","    c[i] += a[0] * b[i];","    int z = 1;","    while ((i & (z - 1)) == z - 1 && (int) a.size() > z) {","      vector<T> a_mul(a.begin() + z, a.begin() + min(z << 1, (int) a.size()));","      vector<T> b_mul(b.end() - z, b.end());","      vector<T> c_mul = a_mul * b_mul;","      if ((int) c.size() <= i + (int) c_mul.size()) {","        c.resize(i + c_mul.size() + 1);","      }","      for (int j = 0; j < (int) c_mul.size(); j++) {","        c[i + 1 + j] += c_mul[j];","      }","      z <<= 1;","    }","    return c[i];","  }","};"],
        "description": "Poly",
    }
    ,
    "Fft": {
        "scope": "cpp",
        "prefix": "fft",
        "body": ["namespace fft {","","typedef double dbl;","","struct num {","  dbl x, y;","  num() { x = y = 0; }","  num(dbl x_, dbl y_) : x(x_), y(y_) {}","};","","inline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }","inline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }","inline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }","inline num conj(num a) { return num(a.x, -a.y); }","","int base = 1;","vector<num> roots = {{0, 0}, {1, 0}};","vector<int> rev = {0, 1};","","const dbl PI = static_cast<dbl>(acosl(-1.0));","","void ensure_base(int nbase) {","  if (nbase <= base) {","    return;","  }","  rev.resize(1 << nbase);","  for (int i = 0; i < (1 << nbase); i++) {","    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));","  }","  roots.resize(1 << nbase);","  while (base < nbase) {","    dbl angle = 2 * PI / (1 << (base + 1));","    //      num z(cos(angle), sin(angle));","    for (int i = 1 << (base - 1); i < (1 << base); i++) {","      roots[i << 1] = roots[i];","      //        roots[(i << 1) + 1] = roots[i] * z;","      dbl angle_i = angle * (2 * i + 1 - (1 << base));","      roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));","    }","    base++;","  }","}","","void fft(vector<num>& a, int n = -1) {","  if (n == -1) {","    n = (int) a.size();","  }","  assert((n & (n - 1)) == 0);","  int zeros = __builtin_ctz(n);","  ensure_base(zeros);","  int shift = base - zeros;","  for (int i = 0; i < n; i++) {","    if (i < (rev[i] >> shift)) {","      swap(a[i], a[rev[i] >> shift]);","    }","  }","  for (int k = 1; k < n; k <<= 1) {","    for (int i = 0; i < n; i += 2 * k) {","      for (int j = 0; j < k; j++) {","        num z = a[i + j + k] * roots[j + k];","        a[i + j + k] = a[i + j] - z;","        a[i + j] = a[i + j] + z;","      }","    }","  }","}","","vector<num> fa, fb;","","vector<long long> square(const vector<int>& a) {","  if (a.empty()) {","    return {};","  }","  int need = (int) a.size() + (int) a.size() - 1;","  int nbase = 1;","  while ((1 << nbase) < need) nbase++;","  ensure_base(nbase);","  int sz = 1 << nbase;","  if ((sz >> 1) > (int) fa.size()) {","    fa.resize(sz >> 1);","  }","  for (int i = 0; i < (sz >> 1); i++) {","    int x = (2 * i < (int) a.size() ? a[2 * i] : 0);","    int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);","    fa[i] = num(x, y);","  }","  fft(fa, sz >> 1);","  num r(1.0 / (sz >> 1), 0.0);","  for (int i = 0; i <= (sz >> 2); i++) {","    int j = ((sz >> 1) - i) & ((sz >> 1) - 1);","    num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);","    num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);","    num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];","    num tmp = fe * fo;","    fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));","    fa[j] = r * (aux + num(0, 2) * tmp);","  }","  fft(fa, sz >> 1);","  vector<long long> res(need);","  for (int i = 0; i < need; i++) {","    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);","  }","  return res;","}","","vector<long long> multiply(const vector<int>& a, const vector<int>& b) {","  if (a.empty() || b.empty()) {","    return {};","  }","  if (a == b) {","    return square(a);","  }","  int need = (int) a.size() + (int) b.size() - 1;","  int nbase = 1;","  while ((1 << nbase) < need) nbase++;","  ensure_base(nbase);","  int sz = 1 << nbase;","  if (sz > (int) fa.size()) {","    fa.resize(sz);","  }","  for (int i = 0; i < sz; i++) {","    int x = (i < (int) a.size() ? a[i] : 0);","    int y = (i < (int) b.size() ? b[i] : 0);","    fa[i] = num(x, y);","  }","  fft(fa, sz);","  num r(0, -0.25 / (sz >> 1));","  for (int i = 0; i <= (sz >> 1); i++) {","    int j = (sz - i) & (sz - 1);","    num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;","    fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;","    fa[i] = z;","  }","  for (int i = 0; i < (sz >> 1); i++) {","    num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);","    num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];","    fa[i] = A0 + A1 * num(0, 1);","  }","  fft(fa, sz >> 1);","  vector<long long> res(need);","  for (int i = 0; i < need; i++) {","    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);","  }","  return res;","}","","vector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {","  if (a.empty() || b.empty()) {","    return {};","  }","  int eq = (a.size() == b.size() && a == b);","  int need = (int) a.size() + (int) b.size() - 1;","  int nbase = 0;","  while ((1 << nbase) < need) nbase++;","  ensure_base(nbase);","  int sz = 1 << nbase;","  if (sz > (int) fa.size()) {","    fa.resize(sz);","  }","  for (int i = 0; i < (int) a.size(); i++) {","    int x = (a[i] % m + m) % m;","    fa[i] = num(x & ((1 << 15) - 1), x >> 15);","  }","  fill(fa.begin() + a.size(), fa.begin() + sz, num{0, 0});","  fft(fa, sz);","  if (sz > (int) fb.size()) {","    fb.resize(sz);","  }","  if (eq) {","    copy(fa.begin(), fa.begin() + sz, fb.begin());","  } else {","    for (int i = 0; i < (int) b.size(); i++) {","      int x = (b[i] % m + m) % m;","      fb[i] = num(x & ((1 << 15) - 1), x >> 15);","    }","    fill(fb.begin() + b.size(), fb.begin() + sz, num{0, 0});","    fft(fb, sz);","  }","  dbl ratio = 0.25 / sz;","  num r2(0, -1);","  num r3(ratio, 0);","  num r4(0, -ratio);","  num r5(0, 1);","  for (int i = 0; i <= (sz >> 1); i++) {","    int j = (sz - i) & (sz - 1);","    num a1 = (fa[i] + conj(fa[j]));","    num a2 = (fa[i] - conj(fa[j])) * r2;","    num b1 = (fb[i] + conj(fb[j])) * r3;","    num b2 = (fb[i] - conj(fb[j])) * r4;","    if (i != j) {","      num c1 = (fa[j] + conj(fa[i]));","      num c2 = (fa[j] - conj(fa[i])) * r2;","      num d1 = (fb[j] + conj(fb[i])) * r3;","      num d2 = (fb[j] - conj(fb[i])) * r4;","      fa[i] = c1 * d1 + c2 * d2 * r5;","      fb[i] = c1 * d2 + c2 * d1;","    }","    fa[j] = a1 * b1 + a2 * b2 * r5;","    fb[j] = a1 * b2 + a2 * b1;","  }","  fft(fa, sz);","  fft(fb, sz);","  vector<int> res(need);","  for (int i = 0; i < need; i++) {","    long long aa = llround(fa[i].x);","    long long bb = llround(fb[i].x);","    long long cc = llround(fa[i].y);","    res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);","  }","  return res;","}","","}  // namespace fft","","template <typename T>","typename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type operator*(","    const vector<Modular<T>>& a,","    const vector<Modular<T>>& b) {","  if (a.empty() || b.empty()) {","    return {};","  }","  if (min(a.size(), b.size()) < 150) {","    vector<Modular<T>> c(a.size() + b.size() - 1, 0);","    for (int i = 0; i < (int) a.size(); i++) {","      for (int j = 0; j < (int) b.size(); j++) {","        c[i + j] += a[i] * b[j];","      }","    }","    return c;","  }","  vector<int> a_mul(a.size());","  for (int i = 0; i < (int) a.size(); i++) {","    a_mul[i] = static_cast<int>(a[i]);","  }","  vector<int> b_mul(b.size());","  for (int i = 0; i < (int) b.size(); i++) {","    b_mul[i] = static_cast<int>(b[i]);","  }","  vector<int> c_mul = fft::multiply_mod(a_mul, b_mul, T::value);","  vector<Modular<T>> c(c_mul.size());","  for (int i = 0; i < (int) c.size(); i++) {","    c[i] = c_mul[i];","  }","  return c;","}","","template <typename T>","typename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type& operator*=(","    vector<Modular<T>>& a,","    const vector<Modular<T>>& b) {","  return a = a * b;","}"],
        "description": "Fft",
    }
    ,
    "Angle Sweep": {
        "scope": "cpp",
        "prefix": "anglesweep",
        "body": ["void AngleSweep(int n, const vector<Point>& p) {","  sort(p.begin(), p.end());","  vector<int> order(n);","  iota(order.begin(), order.end(), 0);","  vector<int> pos(n);","  iota(pos.begin(), pos.end(), 0);","","  // events (when two points swap positions in the order)","  vector<tuple<Point, int, int>> events;","  for (int i = 0; i < n; i++) {","    for (int j = i + 1; j < n; j++) { // only sweep 180 degrees","      events.emplace_back(p[j] - p[i], i, j);","    }","  }","  sort(events.begin(), events.end(), [&](auto a, auto b) {","    Point m1 = get<0>(a);","    Point m2 = get<0>(b);","    int c = m1.cmp_polar(m2);","    return (c == -1);","  });","","  int beg = 0;","  int E = (int) events.size();","  while (beg < E) {","    int end = beg;","    Point slope = get<0>(events[beg]);","    while (end < E && cross(slope, get<0>(events[end])) == 0) {","      end += 1;","    }","    vector<int> changed;","    for (int z = beg; z < end; z++) {","      const auto [_, i, j] = events[z];","      // in case of multiple colinear points","      --pos[j];","      ++pos[i];","      changed.push_back(i);","      changed.push_back(j);","    }","    for (int i : changed) {","      order[pos[i]] = i;","    }","","    for (int z = beg; z < end; z++) {","      int i, j;","      tie(ignore, i, j) = events[z];","      ","      // process the line segment (p[i], p[j])","      $1","    }","    ","    beg = end;","  }","}"],
        "description": "Angle Sweep",
    }
    ,
    "Point": {
        "scope": "cpp",
        "prefix": "point",
        "body": ["template <typename T>","struct TPoint {","  T x;","  T y;","  int id;","","  TPoint() : x(0), y(0), id(-1) {}","  TPoint(const T& x_, const T& y_) : x(x_), y(y_), id(-1) {}","  TPoint(const T& x_, const T& y_, int id_) : x(x_), y(y_), id(id_) {}","","  static constexpr T eps = static_cast<T>(1e-9);","","  inline TPoint operator+(const TPoint& rhs) const { return TPoint(x + rhs.x, y + rhs.y); }","  inline TPoint operator-(const TPoint& rhs) const { return TPoint(x - rhs.x, y - rhs.y); }","  inline TPoint operator*(const T& rhs) const { return TPoint(x * rhs, y * rhs); }","  inline TPoint operator/(const T& rhs) const { return TPoint(x / rhs, y / rhs); }","  ","  friend T dot(const TPoint& a, const TPoint& b) {","    return a.x * b.x + a.y * b.y;","  }","","  friend T cross(const TPoint& a, const TPoint& b) {","    return a.x * b.y - a.y * b.x;","  }","","  inline T abs2() const {","    return x * x + y * y;","  }","","  inline bool operator<(const TPoint& rhs) const {","    return (y < rhs.y || (y == rhs.y && x < rhs.x));","  }","","  inline bool is_upper() const {","    return (y > eps || (abs(y) <= eps && x > eps));","  }","","  inline int cmp_polar(const TPoint& rhs) const {","    assert(abs(x) > eps || abs(y) > eps);","    assert(abs(rhs.x) > eps || abs(rhs.y) > eps);","    bool a = is_upper();","    bool b = rhs.is_upper();","    if (a != b) {","      return (a ? -1 : 1);","    }","    long long v = x * rhs.y - y * rhs.x;","    return (v > eps ? -1 : (v < -eps ? 1 : 0));","  }","};","","template <typename T>","T TwiceSignedArea(int n, const vector<TPoint<T>>& p) {","  T res = 0;","  for (int i = 0; i < n; i++) {","    res += cross(p[i], p[(i + 1) % n]);","  }","  return res;","}","","template <typename T>","T TwiceSignedArea(const vector<TPoint<T>>& p) {","  return TwiceSignedArea((int) p.size(), p);","}","","using Point = TPoint<${1:long long}>;","","template <typename T>","string to_string(const TPoint<T>& p) {","  string res = \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";","  if (p.id != -1) {","    res = \"id \" + to_string(p.id) + \": \" + res;","  }","  return res;","}"],
        "description": "Point",
    }
    ,
    "Convex Hull": {
        "scope": "cpp",
        "prefix": "convexhull",
        "body": ["vector<Point> ConvexHull(vector<Point> p) {","  int n = (int) p.size();","  if (n <= 2) {","    return p;","  }","  sort(p.begin(), p.end(), [&](const Point& a, const Point& b) {","    return (a.x != b.x ? (a.x < b.x) : (a.y < b.y));","  });","  vector<Point> res;","  {","    // lower hull","    int sz = 0;","    for (const Point& pt : p) {","      while (sz >= 2 && !LeftTurn(res[sz - 2], res.back(), pt)) {","        res.pop_back();","        sz -= 1;","      }","      res.push_back(pt);","      sz += 1;","    }","  }","  {","    // upper hull","    vector<Point> upper;","    int sz = 0;","    for (const Point& pt : p) {","      while (sz >= 2 && !RightTurn(upper[sz - 2], upper.back(), pt)) {","        upper.pop_back();","        sz -= 1;","      }","      upper.push_back(pt);","      sz += 1;","    }","    assert(upper[0].id == res[0].id && upper.back().id == res.back().id);","    // exclude the first and last points","    for (int j = sz - 2; j >= 1; j--) {","      res.push_back(upper[j]);","    }","  }","  return res;","  // given a set of (distinct) points,","  // returns the points on the convex hull in counter-clockwise order","}"],
        "description": "Convex Hull",
    }
    ,
    "Line Segment": {
        "scope": "cpp",
        "prefix": "linesegment",
        "body": ["/*","A class to represent a line segment.","","Verification: ","*/","","class LineSegment : public Line {"," public:","  using Line::a;","  using Line::b;","  using Line::c;","","  Point p;","  Point q;","","  LineSegment(const Point& _p, const Point& _q) : Line(_p, _q), p(_p), q(_q) {","  }","};","","Point intersect(const LineSegment& k, const LineSegment& l) {","  Point p = k.intersect(l);  // Line intersect","  if (p == NULL || !p.on_segment(k) || !p.on_segment(l)) {","    return NULL;","  }","  return p;","}","","/**"," * Returns the point on k closest to p."," * @param k the LineSegment to check"," * @param p the Point to compute the minimum distance to"," */","Point closest(const LineSegment& k, const Point& p) {","  if (dot(p - k.p, k.q - k.p) < 0) {","    return k.p;","  }","  if (dot(p - k.q, k.p - k.q) < 0) {","    return k.q;","  }","  T dist = abs(k.a * p.x + k.b * p.y + k.c);","  // unfinished lol","}"],
        "description": "Line Segment",
    }
    ,
    "Area": {
        "scope": "cpp",
        "prefix": "area",
        "body": ["/*","Verification:","","","Usage:","v is a vector of points determining a non-selfintersecting polygon","returns the signed area of the polygon; positive if the points are given in","counterclockwise order and negative if given in clockwise order.","*/","","template <typename T>","T area(int n, const vector<Point<T>>& v) {","  T a = 0;","  for (int i = 0; i < n; i++) {","    a += v[i].x * v[(i + 1) % n].y - v[i].y * v[(i + 1) % n].x;","  }","  return a / 2;","}","","template <typename T>","T area(const vector<Point<T>>& v) {","  return area((int) v.size(), v);","}"],
        "description": "Area",
    }
    ,
    "Compress": {
        "scope": "cpp",
        "prefix": "compress",
        "body": ["template <typename T>","void MakeUnique(vector<T>& v) {","  sort(v.begin(), v.end());","  v.resize(unique(v.begin(), v.end()) - v.begin());","}","","void Compress(vector<int>& a, const vector<int>& v) {","  int n = a.size();","  for (int i = 0; i < n; i++) {","    a[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin();","  }","}","","void Compress(vector<int>& a) {","  vector<int> v = a;","  MakeUnique(v);","  Compress(a, v);","}","","template <typename T>","vector<int> Compressed(const vector<T>& a, const vector<T>& v) {","  int n = (int) a.size();","  vector<int> res(n);","  for (int i = 0; i < n; i++) {","    res[i] = (int) (lower_bound(v.begin(), v.end(), a[i]) - v.begin());","  }","  return res;","}","","template <typename T>","vector<int> Compressed(vector<T>& a) {","  vector<T> v = a;","  MakeUnique(v);","  return Compressed(a, v);","}"],
        "description": "Compress",
    }
    ,
    "Interactive Cache": {
        "scope": "cpp",
        "prefix": "interactivecache",
        "body": ["// don't cache queries when there is a low memory limit","map<$1, int> mp;","","int Ask($1) {","  auto it = mp.find(x);","  if (it != mp.end()) {","    return it->second;","  }","  // print query; don't forget to flush the output","  $2","  int res;","  cin >> res;","  if (CACHE) {","    mp[x] = res;","  }","  return res;","}","","void Answer($3) {","  // print the answer; don't forget to flush the output","  $4","}"],
        "description": "Interactive Cache",
    }
    ,
    "Int128": {
        "scope": "cpp",
        "prefix": "int128",
        "body": ["string to_string(__int128 x) {","  if (x == 0) {","    return \"0\";","  }","  bool negative = false;","  if (x < 0) {","    negative = true;","    x = -x;","  }","  string res = \"\";","  while (x > 0) {","    int d = x % 10;","    x /= 10;","    res += (char) ('0' + d);","  }","  if (negative) {","    res += \"-\";","  }","  reverse(res.begin(), res.end());","  return res;","}","","__int128 stoi128(const string& s) {","  assert(!s.empty());","  int start = 0;","  bool neg = false;","  if (s[0] == '-') {","    start = 1;","    neg = true;","  }","  __int128 res = 0;","  for (int i = start; i < (int) s.size(); i++) {","    res = res * 10 + (int) (s[i] - '0');","  }","  if (neg) {","    res = -res;","  }","  return res;","}","","std::ostream& operator<<(std::ostream& stream, const __int128& number) {","  return stream << to_string(number);","}","","std::istream& operator>>(std::istream& stream, __int128& number) {","  string x;","  stream >> x;","  number = stoi128(x);","  return stream;","}"],
        "description": "Int128",
    }
    ,
    "Interactive": {
        "scope": "cpp",
        "prefix": "interactive",
        "body": ["int Ask($1) {","  // print query; don't forget to flush the output","  $2","  int res;","  cin >> res;","  if (CACHE) {","    mp[x] = res;","  }","  return res;","}","","void Answer($3) {","  // print the answer; don't forget to flush the output","  $4","}"],
        "description": "Interactive",
    }
    ,
    "Lis": {
        "scope": "cpp",
        "prefix": "lis",
        "body": ["template <typename T>","int lis(const vector<T>& a) { // strictly increasing!","  vector<T> best;","  for (const T& x : a) {","    auto it = lower_bound(best.begin(), best.end(), x);","    if (it == best.end()) {","      best.push_back(x);","    } else {","      *it = x;","    }","  }","  return (int) best.size();","}"],
        "description": "Lis",
    }
    ,
    "Code Template": {
        "scope": "cpp",
        "prefix": "codetemplate",
        "body": ["/*"," * author:  ADMathNoob"," * created: DATE"," * problem: PROBLEM_LINK"," */","","/*","Comments about problem:","","","*/","","#include <bits/stdc++.h>","","using namespace std;","","int main() {","  ios::sync_with_stdio(0);","  cin.tie(0);","  $1","  return 0;","}"],
        "description": "Code Template",
    }
    ,
    "Debug": {
        "scope": "cpp",
        "prefix": "debug",
        "body": ["// can't have namespaces, else to_string(int) is hidden, for example","","template <typename A, typename B>","string to_string(pair<A, B> p);","","template <typename A, typename B, typename C>","string to_string(tuple<A, B, C> p);","","template <typename A, typename B, typename C, typename D>","string to_string(tuple<A, B, C, D> p);","","string to_string(const string& s) {","  return '\"' + s + '\"';","}","","string to_string(const char* s) {","  return to_string((string) s);","}","","string to_string(const char c) {","  string s = \"'\";","  s += c;","  s += \"'\";","  return s;","}","","string to_string(bool b) {","  return (b ? \"true\" : \"false\");","}","","string to_string(vector<bool> v) {","  bool first = true;","  string res = \"{\";","  for (int i = 0; i < (int) v.size(); i++) {","    if (!first) {","      res += \", \";","    }","    first = false;","    res += to_string(v[i]);","  }","  res += \"}\";","  return res;","}","","template <size_t N>","string to_string(bitset<N> v) {","  string res = \"\";","  for (size_t i = 0; i < N; i++) {","    res += static_cast<char>('0' + v[i]);","  }","  return res;","}","","template <typename A>","string to_string(A v) {","  bool first = true;","  string res = \"{\";","  for (const auto& x : v) {","    if (!first) {","      res += \", \";","    }","    first = false;","    res += to_string(x);","  }","  res += \"}\";","  return res;","}","","template <typename A, typename B>","string to_string(pair<A, B> p) {","  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";","}","","template <typename A, typename B, typename C>","string to_string(tuple<A, B, C> p) {","  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";","}","","template <typename A, typename B, typename C, typename D>","string to_string(tuple<A, B, C, D> p) {","  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";","}","","void debug_commas() {","}","","template <typename Head, typename... Tail>","void debug_commas(Head H, Tail... T) {","  // comma before each element","  cerr << \", \" << to_string(H);","  debug_commas(T...);","}","","template <typename Head, typename... Tail>","void debug_better(Head H, Tail... T) {","  cerr << \"[\" << to_string(H);","  debug_commas(T...);","  cerr << \"]\" << endl;","}","","// print an empty line","void debug_out() {","#ifdef _DEBUG","  cerr << endl;","#endif","}","","// can't call debug with no arguments","#ifdef _DEBUG","#define debug(...)                      \\","  do {                                  \\","    cerr << \"\" << #__VA_ARGS__ << \": \"; \\","    debug_better(__VA_ARGS__);          \\","  } while (false)","#else","#define debug(...) 42","#endif"],
        "description": "Debug",
    }
    }